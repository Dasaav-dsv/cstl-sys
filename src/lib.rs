/* automatically generated by rust-bindgen 0.71.1 */

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

pub type wchar_t = ::std::os::raw::c_ushort;
#[doc = " Opaque memory allocator interface.\n\n The caller is responsible for making sure an allocator owns and is compatible\n for freeing memory of a given container.\n\n `aligned_alloc` and `aligned_free` must not be null, while `allocator` can\n be used to pass any opaque data (if any) directly to the bound functions.\n\n A strict alignment requirement may be imposed by allocated types.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSTL_Alloc {
    #[doc = " Pointer to opaque data, passed to bound memory allocation functions.\n"]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " Must return a memory block of at least `size` bytes that is at least\n as aligned as `alignment`\n"]
    pub aligned_alloc: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            size: usize,
            alignment: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Must be able to free previously allocated memory.\n\n The caller is responsible for allocator compatibility.\n"]
    pub aligned_free: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            memory: *mut ::std::os::raw::c_void,
            size: usize,
            alignment: usize,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_Alloc"][::std::mem::size_of::<CSTL_Alloc>() - 24usize];
    ["Alignment of CSTL_Alloc"][::std::mem::align_of::<CSTL_Alloc>() - 8usize];
    ["Offset of field: CSTL_Alloc::opaque"][::std::mem::offset_of!(CSTL_Alloc, opaque) - 0usize];
    ["Offset of field: CSTL_Alloc::aligned_alloc"]
        [::std::mem::offset_of!(CSTL_Alloc, aligned_alloc) - 8usize];
    ["Offset of field: CSTL_Alloc::aligned_free"]
        [::std::mem::offset_of!(CSTL_Alloc, aligned_free) - 16usize];
};
#[doc = " Basic type info used in place of a type template parameter.\n\n Two `CSTL_Type` instances are compatible iff their size and alignment\n are equal and the bound functions can operate interchangeably.\n\n It is a logic error to use incompatible `CSTL_Type` instances one\n after another when manipulating an object.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSTL_Type {
    #[doc = " Size of the type in bytes, including any padding bytes.\n\n Must be a non-zero multiple of `1 << align_lg`.\n"]
    pub size: usize,
    #[doc = " Fixed point reciprocal of the type's size, used for\n fast division and remainder operations.\n\n Calculated automatically by `CSTL_define_*_type`.\n"]
    pub size_rcp: usize,
    #[doc = " Right shift of the fixed point reciprocal of the type's size,\n used for fast division and remainder operations.\n\n Calculated automatically by `CSTL_define_*_type`.\n"]
    pub size_rcp_sh: u8,
    #[doc = " Natural alignment of the type in bytes (log2).\n\n Calculated automatically by `CSTL_define_*_type`.\n"]
    pub align_lg: u8,
    #[doc = " Determines whether `move_from` can be called on a `void*` pointer\n to an object of this type.\n\n Set by `CSTL_define_*_type` or manually.\n"]
    pub use_move_from: u8,
    #[doc = " Opaque bitfield with unstable ABI.\n"]
    pub internal_flags: u8,
    #[doc = " Bound copy constructor function.\n\n It is NOT permitted to mutate the `source`.\n\n If null a `memmove(new_instance, src, size)` will be used in its stead.\n"]
    pub copy_from: ::std::option::Option<
        unsafe extern "C" fn(
            new_instance: *mut ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Bound move constructor function.\n\n It is permitted to mutate the `source`, therefore it is suitable\n for a move constructor.\n\n Remember that the moved-from object must stay in a valid state\n and be able to be destroyed after this call.\n\n If null a `memmove(new_instance, src, size)` will be used in its stead.\n"]
    pub move_from: ::std::option::Option<
        unsafe extern "C" fn(
            new_instance: *mut ::std::os::raw::c_void,
            src: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Bound destructor function.\n\n If null a `memset(instance, 0xDE, size)` will be used in its stead.\n"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(instance: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_Type"][::std::mem::size_of::<CSTL_Type>() - 48usize];
    ["Alignment of CSTL_Type"][::std::mem::align_of::<CSTL_Type>() - 8usize];
    ["Offset of field: CSTL_Type::size"][::std::mem::offset_of!(CSTL_Type, size) - 0usize];
    ["Offset of field: CSTL_Type::size_rcp"][::std::mem::offset_of!(CSTL_Type, size_rcp) - 8usize];
    ["Offset of field: CSTL_Type::size_rcp_sh"]
        [::std::mem::offset_of!(CSTL_Type, size_rcp_sh) - 16usize];
    ["Offset of field: CSTL_Type::align_lg"][::std::mem::offset_of!(CSTL_Type, align_lg) - 17usize];
    ["Offset of field: CSTL_Type::use_move_from"]
        [::std::mem::offset_of!(CSTL_Type, use_move_from) - 18usize];
    ["Offset of field: CSTL_Type::internal_flags"]
        [::std::mem::offset_of!(CSTL_Type, internal_flags) - 19usize];
    ["Offset of field: CSTL_Type::copy_from"]
        [::std::mem::offset_of!(CSTL_Type, copy_from) - 24usize];
    ["Offset of field: CSTL_Type::move_from"]
        [::std::mem::offset_of!(CSTL_Type, move_from) - 32usize];
    ["Offset of field: CSTL_Type::destroy"][::std::mem::offset_of!(CSTL_Type, destroy) - 40usize];
};
#[doc = " Reference to a mutable `CSTL_TypeRef`.\n\n Must not be null.\n"]
pub type CSTL_TypeRef = *mut CSTL_Type;
#[doc = " Reference to a const `CSTL_TypeRef`.\n\n Must not be null.\n"]
pub type CSTL_TypeCRef = *const CSTL_Type;
#[doc = " Type info used in place of a template parameter for a type that can be compared.\n\n The type must establish an equivalence relation:\n `is_eq(a, b) == true` => `is_eq(b, a) == true`,\n `is_eq(a, b) == true` && `is_eq(b, c) == true` => `is_eq(a, c) == true`,\n\n Base `CSTL_Type` behavior and size and alignment requirements are unchanged.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSTL_EqType {
    #[doc = " The underlying type info.\n"]
    pub base: CSTL_Type,
    #[doc = " Bound \"equality\" binary function.\n\n Must establish an equivalence relation.\n\n If null a `memcmp(lhs, rhs, size) == 0` will be used in its stead.\n"]
    pub is_eq: ::std::option::Option<
        unsafe extern "C" fn(
            lhs: *const ::std::os::raw::c_void,
            rhs: *const ::std::os::raw::c_void,
        ) -> bool,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_EqType"][::std::mem::size_of::<CSTL_EqType>() - 56usize];
    ["Alignment of CSTL_EqType"][::std::mem::align_of::<CSTL_EqType>() - 8usize];
    ["Offset of field: CSTL_EqType::base"][::std::mem::offset_of!(CSTL_EqType, base) - 0usize];
    ["Offset of field: CSTL_EqType::is_eq"][::std::mem::offset_of!(CSTL_EqType, is_eq) - 48usize];
};
#[doc = " Reference to a mutable `CSTL_EqType`.\n\n Must not be null.\n"]
pub type CSTL_EqTypeRef = *mut CSTL_EqType;
#[doc = " Reference to a const `CSTL_EqType`.\n\n Must not be null.\n"]
pub type CSTL_EqTypeCRef = *const CSTL_EqType;
#[doc = " Type info used in place of a template parameter for a type that can be compared.\n\n The type must establish at least a strict weak ordering:\n `is_lt(a, b) == true` => `is_lt(b, a) == false`\n `is_lt(a, b) == true` && `is_lt(b, c) == true` => `is_lt(a, c) == true`\n\n Base `CSTL_EqType` behavior and size and alignment requirements are unchanged.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSTL_CompType {
    #[doc = " The underlying type info.\n"]
    pub base: CSTL_EqType,
    #[doc = " Bound \"less than\" binary function.\n\n Must establish a strict weak ordering relation.\n\n If null a `memcmp(lhs, rhs, size) < 0` will be used in its stead.\n"]
    pub is_lt: ::std::option::Option<
        unsafe extern "C" fn(
            lhs: *const ::std::os::raw::c_void,
            rhs: *const ::std::os::raw::c_void,
        ) -> bool,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_CompType"][::std::mem::size_of::<CSTL_CompType>() - 64usize];
    ["Alignment of CSTL_CompType"][::std::mem::align_of::<CSTL_CompType>() - 8usize];
    ["Offset of field: CSTL_CompType::base"][::std::mem::offset_of!(CSTL_CompType, base) - 0usize];
    ["Offset of field: CSTL_CompType::is_lt"]
        [::std::mem::offset_of!(CSTL_CompType, is_lt) - 56usize];
};
#[doc = " Reference to a mutable `CSTL_CompType`.\n\n Must not be null.\n"]
pub type CSTL_CompTypeRef = *mut CSTL_CompType;
#[doc = " Reference to a const `CSTL_CompType`.\n\n Must not be null.\n"]
pub type CSTL_CompTypeCRef = *const CSTL_CompType;
#[doc = " Type info used in place of a template parameter for a type that can be hashed.\n\n The relation `is_eq(a, b)` => `hash(a) == hash(b)` must hold.\n\n Base `CSTL_EqType` behavior and size and alignment requirements are unchanged.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSTL_HashType {
    #[doc = " The underlying type info.\n"]
    pub base: CSTL_EqType,
    #[doc = " Bound hash function.\n\n If `is_eq(a, b)` then `hash(a) == hash(b)`.\n\n If null an STL `std::hash` conforming implementation will be used in its stead.\n"]
    pub hash: ::std::option::Option<
        unsafe extern "C" fn(instance: *const ::std::os::raw::c_void) -> usize,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_HashType"][::std::mem::size_of::<CSTL_HashType>() - 64usize];
    ["Alignment of CSTL_HashType"][::std::mem::align_of::<CSTL_HashType>() - 8usize];
    ["Offset of field: CSTL_HashType::base"][::std::mem::offset_of!(CSTL_HashType, base) - 0usize];
    ["Offset of field: CSTL_HashType::hash"][::std::mem::offset_of!(CSTL_HashType, hash) - 56usize];
};
#[doc = " Reference to a mutable `CSTL_HashType`.\n\n Must not be null.\n"]
pub type CSTL_HashTypeRef = *mut CSTL_HashType;
#[doc = " Reference to a const `CSTL_HashType`.\n\n Must not be null.\n"]
pub type CSTL_HashTypeCRef = *const CSTL_HashType;
#[doc = " Other error, zero initialized state of `CSTL_TypeErr`.\n"]
pub const CSTL_TypeErr_Other: CSTL_TypeErr = 0;
#[doc = " No error.\n"]
pub const CSTL_TypeErr_Ok: CSTL_TypeErr = 1;
#[doc = " Improper size of type.\n\n The size of a type must be a non-zero multiple of its alignment.\n\n Cstl also imposes a maximum size `SIZE_MAX / 2` for optimization reasons.\n\n It follows from the alignment requirement that an alignment of `SIZE_MAX / 2 + 1`\n is impossible, and `size + alignment` cannot overflow.\n"]
pub const CSTL_TypeErr_BadSize: CSTL_TypeErr = 2;
#[doc = " Improper alignment of type.\n\n Types must have a non-zero power of 2 alignment.\n"]
pub const CSTL_TypeErr_Misaligned: CSTL_TypeErr = 3;
#[doc = " Pointer passed as `new_instance` was null.\n"]
pub const CSTL_TypeErr_NullPointer: CSTL_TypeErr = 4;
#[doc = " All possible return values of `CSTL_define_*_type`.\n"]
pub type CSTL_TypeErr = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " Define a type, writing it to `new_instance` and validating parameters.\n\n `copy_from`, `move_from`, `destroy` may be null, in which case their default\n behavior is invoked. See descriptions of these fields in `CSTL_Type`.\n\n If `use_copy_from == false` and `use_move_from == false` most container\n relocation functions will fail.\n"]
    pub fn CSTL_define_type(
        new_instance: *mut CSTL_Type,
        size: usize,
        alignment: usize,
        copy_from: ::std::option::Option<
            unsafe extern "C" fn(
                new_instance: *mut ::std::os::raw::c_void,
                src: *const ::std::os::raw::c_void,
            ),
        >,
        move_from: ::std::option::Option<
            unsafe extern "C" fn(
                new_instance: *mut ::std::os::raw::c_void,
                src: *mut ::std::os::raw::c_void,
            ),
        >,
        destroy: ::std::option::Option<unsafe extern "C" fn(instance: *mut ::std::os::raw::c_void)>,
    ) -> CSTL_TypeErr;
}
unsafe extern "C" {
    #[doc = " Define a type, writing it to `new_instance` and validating parameters.\n\n `copy_from`, `move_from`, `destroy`, `is_eq` may be null, in which case their default\n behavior is invoked. See descriptions of these fields in `CSTL_Type`.\n\n If `use_copy_from == false` and `use_move_from == false` most container\n relocation functions will fail.\n"]
    pub fn CSTL_define_eq_type(
        new_instance: *mut CSTL_EqType,
        size: usize,
        alignment: usize,
        copy_from: ::std::option::Option<
            unsafe extern "C" fn(
                new_instance: *mut ::std::os::raw::c_void,
                src: *const ::std::os::raw::c_void,
            ),
        >,
        move_from: ::std::option::Option<
            unsafe extern "C" fn(
                new_instance: *mut ::std::os::raw::c_void,
                src: *mut ::std::os::raw::c_void,
            ),
        >,
        destroy: ::std::option::Option<unsafe extern "C" fn(instance: *mut ::std::os::raw::c_void)>,
        is_eq: ::std::option::Option<
            unsafe extern "C" fn(
                lhs: *const ::std::os::raw::c_void,
                rhs: *const ::std::os::raw::c_void,
            ) -> bool,
        >,
    ) -> CSTL_TypeErr;
}
unsafe extern "C" {
    #[doc = " Define a type, writing it to `new_instance` and validating parameters.\n\n `copy_from`, `move_from`, `destroy`, `is_eq`, `is_lt` may be null,\n in which case their default behavior is invoked. See descriptions\n of these fields in `CSTL_Type`.\n"]
    pub fn CSTL_define_comp_type(
        new_instance: *mut CSTL_CompType,
        size: usize,
        alignment: usize,
        copy_from: ::std::option::Option<
            unsafe extern "C" fn(
                new_instance: *mut ::std::os::raw::c_void,
                src: *const ::std::os::raw::c_void,
            ),
        >,
        move_from: ::std::option::Option<
            unsafe extern "C" fn(
                new_instance: *mut ::std::os::raw::c_void,
                src: *mut ::std::os::raw::c_void,
            ),
        >,
        destroy: ::std::option::Option<unsafe extern "C" fn(instance: *mut ::std::os::raw::c_void)>,
        is_eq: ::std::option::Option<
            unsafe extern "C" fn(
                lhs: *const ::std::os::raw::c_void,
                rhs: *const ::std::os::raw::c_void,
            ) -> bool,
        >,
        is_lt: ::std::option::Option<
            unsafe extern "C" fn(
                lhs: *const ::std::os::raw::c_void,
                rhs: *const ::std::os::raw::c_void,
            ) -> bool,
        >,
    ) -> CSTL_TypeErr;
}
unsafe extern "C" {
    #[doc = " Define a type, writing it to `new_instance` and validating parameters.\n\n `copy_from`, `move_from`, `destroy`, `is_eq`, `hash` may be null,\n in which case their default behavior is invoked. See descriptions\n of these fields in `CSTL_Type`.\n"]
    pub fn CSTL_define_hash_type(
        new_instance: *mut CSTL_HashType,
        size: usize,
        alignment: usize,
        copy_from: ::std::option::Option<
            unsafe extern "C" fn(
                new_instance: *mut ::std::os::raw::c_void,
                src: *const ::std::os::raw::c_void,
            ),
        >,
        move_from: ::std::option::Option<
            unsafe extern "C" fn(
                new_instance: *mut ::std::os::raw::c_void,
                src: *mut ::std::os::raw::c_void,
            ),
        >,
        destroy: ::std::option::Option<unsafe extern "C" fn(instance: *mut ::std::os::raw::c_void)>,
        is_eq: ::std::option::Option<
            unsafe extern "C" fn(
                lhs: *const ::std::os::raw::c_void,
                rhs: *const ::std::os::raw::c_void,
            ) -> bool,
        >,
        hash: ::std::option::Option<
            unsafe extern "C" fn(instance: *const ::std::os::raw::c_void) -> usize,
        >,
    ) -> CSTL_TypeErr;
}
#[doc = " STL ABI `std::vector` layout.\n\n Does not include the allocator, which nonetheless is a part of the `std::vector`\n structure! You are responsible for including it, since it can take on any form.\n\n Do not manipulate the members directly, use the associated functions!\n"]
#[repr(C)]
pub struct CSTL_VectorVal {
    pub first: *mut ::std::os::raw::c_void,
    pub last: *mut ::std::os::raw::c_void,
    pub end: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_VectorVal"][::std::mem::size_of::<CSTL_VectorVal>() - 24usize];
    ["Alignment of CSTL_VectorVal"][::std::mem::align_of::<CSTL_VectorVal>() - 8usize];
    ["Offset of field: CSTL_VectorVal::first"]
        [::std::mem::offset_of!(CSTL_VectorVal, first) - 0usize];
    ["Offset of field: CSTL_VectorVal::last"]
        [::std::mem::offset_of!(CSTL_VectorVal, last) - 8usize];
    ["Offset of field: CSTL_VectorVal::end"][::std::mem::offset_of!(CSTL_VectorVal, end) - 16usize];
};
#[doc = " Reference to a mutable `CSTL_VectorVal`.\n\n Must not be null.\n"]
pub type CSTL_VectorRef = *mut CSTL_VectorVal;
#[doc = " Reference to a const `CSTL_VectorVal`.\n\n Must not be null.\n"]
pub type CSTL_VectorCRef = *const CSTL_VectorVal;
#[doc = " A representation of the parts making up a vector.\n\n Contains a references to `CSTL_VectorVal` and `CSTL_Type` which must all outlive it.\n\n This struct is *not* `std::vector`, it simply contains references\n to the parts necessary for its manipulation.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSTL_VectorCtx {
    pub instance: CSTL_VectorCRef,
    pub type_: CSTL_TypeCRef,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_VectorCtx"][::std::mem::size_of::<CSTL_VectorCtx>() - 16usize];
    ["Alignment of CSTL_VectorCtx"][::std::mem::align_of::<CSTL_VectorCtx>() - 8usize];
    ["Offset of field: CSTL_VectorCtx::instance"]
        [::std::mem::offset_of!(CSTL_VectorCtx, instance) - 0usize];
    ["Offset of field: CSTL_VectorCtx::type_"]
        [::std::mem::offset_of!(CSTL_VectorCtx, type_) - 8usize];
};
#[doc = " An iterator over elements of a vector.\n\n Contains a reference to a `CSTL_Type` which must outlive it.\n\n Not ABI-compatible with `std::vector::iterator`.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSTL_VectorIter {
    pub pointer: *const ::std::os::raw::c_void,
    pub type_: CSTL_TypeCRef,
    pub owner: CSTL_VectorCRef,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_VectorIter"][::std::mem::size_of::<CSTL_VectorIter>() - 24usize];
    ["Alignment of CSTL_VectorIter"][::std::mem::align_of::<CSTL_VectorIter>() - 8usize];
    ["Offset of field: CSTL_VectorIter::pointer"]
        [::std::mem::offset_of!(CSTL_VectorIter, pointer) - 0usize];
    ["Offset of field: CSTL_VectorIter::type_"]
        [::std::mem::offset_of!(CSTL_VectorIter, type_) - 8usize];
    ["Offset of field: CSTL_VectorIter::owner"]
        [::std::mem::offset_of!(CSTL_VectorIter, owner) - 16usize];
};
unsafe extern "C" {
    #[doc = " Initializes the vector pointed to by `context->instance`, but does not allocate any memory.\n\n An initialized vector can be trivially destroyed without leaks as long\n as no functions that allocate (push, insert, reserve, etc.) have been called on it.\n\n Re-initializing a vector with a backing memory allocation will leak the old\n memory allocation.\n"]
    pub fn CSTL_vector_construct(context: CSTL_VectorCtx);
}
unsafe extern "C" {
    #[doc = " Destroys the vector pointed to by `context->instance`, destroying elements\n and freeing the backing storage.\n"]
    pub fn CSTL_vector_destroy(context: CSTL_VectorCtx, alloc: *mut CSTL_Alloc);
}
unsafe extern "C" {
    #[doc = " Destroys vector contents, replacing them with `new_size` copies of `value`.\n\n If `new_size > CSTL_vector_max_size(context.type)` (vector too long)\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n `value` cannot point to an element inside the vector.\n"]
    pub fn CSTL_vector_assign(
        context: CSTL_VectorCtx,
        new_size: usize,
        value: *const ::std::os::raw::c_void,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Destroys vector contents, replacing them with a copy of the range `[first, first + new_size)`.\n\n If `new_size > CSTL_vector_max_size(context.type)` (vector too long)\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n `first` cannot point inside the vector.\n"]
    pub fn CSTL_vector_assign_continuous_range(
        context: CSTL_VectorCtx,
        new_size: usize,
        first: *const ::std::os::raw::c_void,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `context->instance` with the contents of `other_context->instance`.\n\n If `propagate_alloc == true && alloc != other_alloc` then storage\n is freed with `alloc` and allocated again with `context->other_alloc` before elements\n are copied. Then, `context->instance` uses `context->other_alloc` as its allocator.\n\n If `propagate_alloc == false` `context->instance` keeps using `alloc` as its allocator,\n potentially reusing its storage.\n\n You are responsible for replacing the allocator outside of `CSTL_VectorVal` if applicable.\n"]
    pub fn CSTL_vector_copy_assign(
        context: CSTL_VectorCtx,
        alloc: *mut CSTL_Alloc,
        other_context: CSTL_VectorCtx,
        other_alloc: *mut CSTL_Alloc,
        propagate_alloc: bool,
    );
}
unsafe extern "C" {
    #[doc = " Moves the contents of `other_context->instance` to the contents of `context->instance`.\n\n If `propagate_alloc == true` storage is replaced with storage of `other_context->instance`.\n Then, `context->instance` uses `context->other_alloc` as its allocator.\n\n If `propagate_alloc == false && alloc != other_alloc` then storage is reused\n and individual elements of `context->other` are moved in.\n Then, `context->instance` uses `alloc` as its allocator.\n\n You are responsible for replacing the allocator outside of `CSTL_VectorVal` if applicable.\n"]
    pub fn CSTL_vector_move_assign(
        context: CSTL_VectorCtx,
        alloc: *mut CSTL_Alloc,
        other_context: CSTL_VectorCtx,
        other_alloc: *mut CSTL_Alloc,
        propagate_alloc: bool,
    );
}
unsafe extern "C" {
    #[doc = " Swaps vector contents.\n\n You are responsible for swapping the allocators.\n"]
    pub fn CSTL_vector_swap(context: CSTL_VectorCtx, other_context: CSTL_VectorCtx);
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the element at `pos`.\n\n If `pos >= CSTL_vector_size(context)` the behavior is undefined.\n"]
    pub fn CSTL_vector_index(context: CSTL_VectorCtx, pos: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the element at `pos`.\n\n If `pos >= CSTL_vector_size(context)` the behavior is undefined.\n"]
    pub fn CSTL_vector_const_index(
        context: CSTL_VectorCtx,
        pos: usize,
    ) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the element at `pos`.\n\n If `pos >= CSTL_vector_size(context)` a null pointer is returned.\n"]
    pub fn CSTL_vector_at(context: CSTL_VectorCtx, pos: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the element at `pos`.\n\n If `pos >= CSTL_vector_size(context)` a null pointer is returned.\n"]
    pub fn CSTL_vector_const_at(
        context: CSTL_VectorCtx,
        pos: usize,
    ) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the first element in the vector.\n\n If `CSTL_vector_empty(context) == true` the behavior is undefined.\n"]
    pub fn CSTL_vector_front(context: CSTL_VectorCtx) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the first element in the vector.\n\n If `CSTL_vector_empty(context) == true` the behavior is undefined.\n"]
    pub fn CSTL_vector_const_front(context: CSTL_VectorCtx) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the last element in the vector.\n\n If `CSTL_vector_empty(context) == true` the behavior is undefined.\n"]
    pub fn CSTL_vector_back(context: CSTL_VectorCtx) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the last element in the vector.\n\n If `CSTL_vector_empty(context) == true` the behavior is undefined.\n"]
    pub fn CSTL_vector_const_back(context: CSTL_VectorCtx) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the underlying storage.\n\n The returned pointer is valid even if the vector is empty,\n in which case it is not dereferenceable.\n"]
    pub fn CSTL_vector_data(context: CSTL_VectorCtx) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the underlying storage.\n\n The returned pointer is valid even if the vector is empty,\n in which case it is not dereferenceable.\n"]
    pub fn CSTL_vector_const_data(context: CSTL_VectorCtx) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Construct an iterator to the first element of the vector.\n\n If the vector is empty: `CSTL_vector_iterator_eq(begin, end) == true`.\n"]
    pub fn CSTL_vector_begin(context: CSTL_VectorCtx) -> CSTL_VectorIter;
}
unsafe extern "C" {
    #[doc = " Construct a const iterator to the first element of the vector.\n\n If the vector is empty: `CSTL_vector_const_iterator_eq(begin, end) == true`.\n"]
    pub fn CSTL_vector_end(context: CSTL_VectorCtx) -> CSTL_VectorIter;
}
unsafe extern "C" {
    #[doc = " Seeks the iterator forwards by `n` elements.\n\n Returns a new iterator at the resulting iterator position.\n"]
    pub fn CSTL_vector_iterator_add(iterator: CSTL_VectorIter, n: isize) -> CSTL_VectorIter;
}
unsafe extern "C" {
    #[doc = " Seeks the iterator backwards by `n` elements.\n\n Returns a new iterator at the resulting iterator position.\n"]
    pub fn CSTL_vector_iterator_sub(iterator: CSTL_VectorIter, n: isize) -> CSTL_VectorIter;
}
unsafe extern "C" {
    #[doc = " Dereferences the iterator at the element it's pointing to.\n\n Returns a pointer to the element.\n\n `iterator` must be dereferenceable, not value initialized\n and pointing to a valid element inside the vector.\n\n It is not valid to mutate an element derived from an iterator obtained with\n a const vector pointer.\n"]
    pub fn CSTL_vector_iterator_deref(iterator: CSTL_VectorIter) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Dereferences the iterator at an element offset `n`.\n\n Returns a pointer to the element.\n\n `iterator` must be dereferenceable at its new position, not value initialized\n and pointing to a valid element inside the vector.\n\n It is not valid to mutate an element derived from an iterator obtained with\n a const vector pointer.\n"]
    pub fn CSTL_vector_iterator_index(
        iterator: CSTL_VectorIter,
        n: isize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Subtracts two iterators and returns the distance measured in elements.\n\n Returns the signed number of elements between two iterators.\n\n They must belong to the same vector and have compatible `CSTL_Type`s.\n"]
    pub fn CSTL_vector_iterator_distance(lhs: CSTL_VectorIter, rhs: CSTL_VectorIter) -> isize;
}
unsafe extern "C" {
    #[doc = " Compares iterators for equality.\n\n They must belong to the same vector and have compatible `CSTL_Type`s.\n"]
    pub fn CSTL_vector_iterator_eq(lhs: CSTL_VectorIter, rhs: CSTL_VectorIter) -> bool;
}
unsafe extern "C" {
    #[doc = " Compares iterators for less than.\n\n They must belong to the same vector and have compatible `CSTL_Type`s.\n"]
    pub fn CSTL_vector_iterator_lt(lhs: CSTL_VectorIter, rhs: CSTL_VectorIter) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the vector is empty or `false` otherwise.\n"]
    pub fn CSTL_vector_empty(context: CSTL_VectorCtx) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the number of elements in the vector.\n"]
    pub fn CSTL_vector_size(context: CSTL_VectorCtx) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the total element capacity of the vector.\n"]
    pub fn CSTL_vector_capacity(context: CSTL_VectorCtx) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the maximum possible number of elements in the vector.\n\n As if by `PTRDIFF_MAX / type->size`.\n"]
    pub fn CSTL_vector_max_size(type_: CSTL_TypeCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " If `new_capacity > CSTL_vector_capacity(context)`, reallocates and expands\n the vector storage.\n\n If `new_capacity` exceeds `CSTL_vector_max_size(context.type)` (vector too long)\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_vector_reserve(
        context: CSTL_VectorCtx,
        new_capacity: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Request removal of unused capacity.\n"]
    pub fn CSTL_vector_shrink_to_fit(context: CSTL_VectorCtx, alloc: *mut CSTL_Alloc);
}
unsafe extern "C" {
    #[doc = " Erase all elements from the vector without affecting capacity.\n"]
    pub fn CSTL_vector_clear(context: CSTL_VectorCtx);
}
unsafe extern "C" {
    #[doc = " Inserts `count` copies of `value` into the vector before `where` and returns\n an iterator to the first newly inserted element.\n\n If `count > CSTL_vector_max_size(context.type) - CSTL_vector_size(context)` (vector too long)\n this function has no effect and returns `CSTL_vector_end(context)`.\n"]
    pub fn CSTL_vector_insert(
        context: CSTL_VectorCtx,
        where_: CSTL_VectorIter,
        count: usize,
        value: *const ::std::os::raw::c_void,
        alloc: *mut CSTL_Alloc,
    ) -> CSTL_VectorIter;
}
unsafe extern "C" {
    #[doc = " Inserts a copy of `value` into the vector before `where` and returns\n an iterator to the newly inserted element.\n\n If `CSTL_vector_size(context) == CSTL_vector_max_size(context.type)` (vector too long)\n this function has no effect and returns `CSTL_vector_end(context)`.\n"]
    pub fn CSTL_vector_emplace(
        context: CSTL_VectorCtx,
        where_: CSTL_VectorIter,
        value: *mut ::std::os::raw::c_void,
        alloc: *mut CSTL_Alloc,
    ) -> CSTL_VectorIter;
}
unsafe extern "C" {
    #[doc = " Inserts a copy of `value` into the vector before `where` and returns\n an iterator to the newly inserted element.\n\n If `CSTL_vector_size(context) == CSTL_vector_max_size(context.type)` (vector too long)\n this function has no effect and returns `CSTL_vector_end(context)`.\n"]
    pub fn CSTL_vector_emplace_const(
        context: CSTL_VectorCtx,
        where_: CSTL_VectorIter,
        value: *const ::std::os::raw::c_void,
        alloc: *mut CSTL_Alloc,
    ) -> CSTL_VectorIter;
}
unsafe extern "C" {
    #[doc = " Removes the element at `where` and returns an iterator following the\n removed element.\n\n The iterator `where` must be valid and dereferenceable.\n"]
    pub fn CSTL_vector_erase(context: CSTL_VectorCtx, where_: CSTL_VectorIter) -> CSTL_VectorIter;
}
unsafe extern "C" {
    #[doc = " Removes elements in the range `[first, last)` and returns an iterator following the\n removed elements.\n\n If `first == last`, no operation is performed.\n"]
    pub fn CSTL_vector_erase_range(
        context: CSTL_VectorCtx,
        first: CSTL_VectorIter,
        last: CSTL_VectorIter,
    ) -> CSTL_VectorIter;
}
unsafe extern "C" {
    #[doc = " Appends a copy of `value` to the end of the vector and returns\n an iterator to the newly inserted element.\n\n If `CSTL_vector_size(context) == CSTL_vector_max_size(context.type)` (vector too long)\n this function has no effect and returns `CSTL_vector_end(instance, type)`.\n"]
    pub fn CSTL_vector_emplace_back(
        context: CSTL_VectorCtx,
        value: *mut ::std::os::raw::c_void,
        alloc: *mut CSTL_Alloc,
    ) -> CSTL_VectorIter;
}
unsafe extern "C" {
    #[doc = " Appends a copy of `value` to the end of the vector and returns\n an iterator to the newly inserted element.\n\n If `CSTL_vector_size(context) == CSTL_vector_max_size(context.type)` (vector too long)\n this function has no effect and returns `CSTL_vector_end(instance, type)`.\n"]
    pub fn CSTL_vector_emplace_back_const(
        context: CSTL_VectorCtx,
        value: *const ::std::os::raw::c_void,
        alloc: *mut CSTL_Alloc,
    ) -> CSTL_VectorIter;
}
unsafe extern "C" {
    #[doc = " Appends a copy of `value` to the end of the vector.\n\n If `CSTL_vector_size(context) == CSTL_vector_max_size(context.type)` (vector too long)\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_vector_push_back(
        context: CSTL_VectorCtx,
        value: *mut ::std::os::raw::c_void,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends a copy of `value` to the end of the vector.\n\n If `CSTL_vector_size(context) == CSTL_vector_max_size(context.type)` (vector too long)\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_vector_push_back_const(
        context: CSTL_VectorCtx,
        value: *const ::std::os::raw::c_void,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Removes the last element from the vector.\n\n If `CSTL_vector_empty(context) == true` the behavior is undefined.\n"]
    pub fn CSTL_vector_pop_back(context: CSTL_VectorCtx);
}
unsafe extern "C" {
    #[doc = " Resizes the vector to contain `new_size` elements.\n\n If `new_size > CSTL_vector_max_size(context.type)` (vector too long)\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_vector_resize(
        context: CSTL_VectorCtx,
        new_size: usize,
        value: *const ::std::os::raw::c_void,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
#[doc = " STL ABI `std::basic_string` layout.\n\n Does not include the allocator, which nonetheless is a part of the `std::basic_string`\n structure! You are responsible for including it, since it can take on any form.\n\n Do not manipulate the members directly, use the associated functions!\n"]
#[repr(C)]
pub struct CSTL_StringVal {
    pub bx: CSTL_StringVal__bindgen_ty_1,
    pub size: usize,
    pub res: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CSTL_StringVal__bindgen_ty_1 {
    pub buf: [::std::os::raw::c_char; 16usize],
    pub ptr: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_StringVal__bindgen_ty_1"]
        [::std::mem::size_of::<CSTL_StringVal__bindgen_ty_1>() - 16usize];
    ["Alignment of CSTL_StringVal__bindgen_ty_1"]
        [::std::mem::align_of::<CSTL_StringVal__bindgen_ty_1>() - 8usize];
    ["Offset of field: CSTL_StringVal__bindgen_ty_1::buf"]
        [::std::mem::offset_of!(CSTL_StringVal__bindgen_ty_1, buf) - 0usize];
    ["Offset of field: CSTL_StringVal__bindgen_ty_1::ptr"]
        [::std::mem::offset_of!(CSTL_StringVal__bindgen_ty_1, ptr) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_StringVal"][::std::mem::size_of::<CSTL_StringVal>() - 32usize];
    ["Alignment of CSTL_StringVal"][::std::mem::align_of::<CSTL_StringVal>() - 8usize];
    ["Offset of field: CSTL_StringVal::bx"][::std::mem::offset_of!(CSTL_StringVal, bx) - 0usize];
    ["Offset of field: CSTL_StringVal::size"]
        [::std::mem::offset_of!(CSTL_StringVal, size) - 16usize];
    ["Offset of field: CSTL_StringVal::res"][::std::mem::offset_of!(CSTL_StringVal, res) - 24usize];
};
#[doc = " Reference to a mutable `CSTL_StringVal`.\n\n Must not be null.\n"]
pub type CSTL_StringRef = *mut CSTL_StringVal;
#[doc = " Reference to a const `CSTL_StringVal`.\n\n Must not be null.\n"]
pub type CSTL_StringCRef = *const CSTL_StringVal;
unsafe extern "C" {
    #[doc = " Initializes the string, but does not allocate any memory.\n\n An initialized string can be trivially destroyed without leaks as long\n as its owned string is small enough to be inline (smaller than CSTL_string_alloc_mask).\n\n Re-initializing a string with a backing memory allocation will leak the old\n memory allocation.\n"]
    pub fn CSTL_string_construct(new_instance: *mut CSTL_StringVal);
}
unsafe extern "C" {
    #[doc = " Destroys the string, freeing the backing storage if necessary.\n"]
    pub fn CSTL_string_destroy(instance: CSTL_StringRef, alloc: *mut CSTL_Alloc);
}
unsafe extern "C" {
    #[doc = " Initializes the string with the substring at offset `other_off`\n in `other` with the length given by `count`.\n\n If `new_instance == NULL` or if `other_off` is outside of the range\n `[other, other + CSTL_string_size(other)]` returns `false` and does nothing,\n otherwise it returns `true`.\n\n If `new_instance == other` the substring operation is performed in-place without\n de-initializing `other`.\n\n Remember that re-initializing a different string with a backing memory allocation\n will leak the old memory allocation.\n"]
    pub fn CSTL_string_substr(
        new_instance: *mut CSTL_StringVal,
        other: CSTL_StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the null-terminated string at `ptr`.\n\n If the length of the string at `ptr` is greater than `CSTL_string_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_assign(
        instance: CSTL_StringRef,
        ptr: *const ::std::os::raw::c_char,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the first `count` characters of the string at `ptr`.\n\n If `n` is greater than `CSTL_string_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_assign_n(
        instance: CSTL_StringRef,
        ptr: *const ::std::os::raw::c_char,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the `count` copies of the character `ch`.\n\n If `count` is greater than `CSTL_string_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_assign_char(
        instance: CSTL_StringRef,
        count: usize,
        ch: ::std::os::raw::c_char,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the substring at offset `other_off` in `other`\n with the length given by `count`.\n\n If `other_off` is outside of the range `[other, other + CSTL_string_size(other)]` returns\n `false` and does nothing, otherwise it returns `true`.\n"]
    pub fn CSTL_string_assign_substr(
        instance: CSTL_StringRef,
        other: CSTL_StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the contents of `other_instance`.\n\n If `propagate_alloc == true && alloc != other_alloc` then storage\n is freed with `alloc` and allocated again with `other_alloc` before contents\n are copied. Then, `instance` uses `other_alloc` as its allocator.\n\n If `propagate_alloc == false` `instance` keeps using `alloc` as its allocator,\n potentially reusing its storage.\n\n You are responsible for replacing the allocator outside of `CSTL_StringVal` if applicable.\n"]
    pub fn CSTL_string_copy_assign(
        instance: CSTL_StringRef,
        alloc: *mut CSTL_Alloc,
        other_instance: CSTL_StringCRef,
        other_alloc: *mut CSTL_Alloc,
        propagate_alloc: bool,
    );
}
unsafe extern "C" {
    #[doc = " Moves the contents of `other_instance` to the contents of `instance`.\n\n If `propagate_alloc == true` storage is replaced with storage of `other_instance`.\n Then, `instance` uses `other_alloc` as its allocator.\n\n If `propagate_alloc == false && alloc != other_alloc` then storage is reused\n and individual characters of `other` are moved in. Then, `instance` uses `alloc` as its allocator.\n\n You are responsible for replacing the allocator outside of `CSTL_StringVal` if applicable.\n"]
    pub fn CSTL_string_move_assign(
        instance: CSTL_StringRef,
        alloc: *mut CSTL_Alloc,
        other_instance: CSTL_StringRef,
        other_alloc: *mut CSTL_Alloc,
        propagate_alloc: bool,
    );
}
unsafe extern "C" {
    #[doc = " Swaps string contents.\n\n You are responsible for swapping the allocators.\n"]
    pub fn CSTL_string_swap(instance: CSTL_StringRef, other_instance: CSTL_StringRef);
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the character at `pos`.\n\n If `pos >= CSTL_string_length(instance)` the behavior is undefined.\n"]
    pub fn CSTL_string_index(instance: CSTL_StringRef, pos: usize) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the character at `pos`.\n\n If `pos >= CSTL_string_length(instance)` the behavior is undefined.\n"]
    pub fn CSTL_string_const_index(
        instance: CSTL_StringCRef,
        pos: usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the character at `pos`.\n\n If `pos >= CSTL_string_length(instance)` a null pointer is returned.\n"]
    pub fn CSTL_string_at(instance: CSTL_StringRef, pos: usize) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the character at `pos`.\n\n If `pos >= CSTL_string_length(instance)` a null pointer is returned.\n"]
    pub fn CSTL_string_const_at(
        instance: CSTL_StringCRef,
        pos: usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the first character.\n\n If `CSTL_string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_string_front(instance: CSTL_StringRef) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the first character.\n\n If `CSTL_string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_string_const_front(instance: CSTL_StringCRef) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the last character.\n\n If `CSTL_string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_string_back(instance: CSTL_StringRef) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the last character.\n\n If `CSTL_string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_string_const_back(instance: CSTL_StringCRef) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the underlying null-terminated array\n serving as character storage.\n\n If `CSTL_string_empty(instance) == true` the pointer is still\n valid and points to a single null character.\n\n The range `[CSTL_string_data(instance), CSTL_string_data(instance) + size]`\n is always valid.\n\n The array may be mutated through the returned pointer excluding\n the past-the-end null terminator.\n"]
    pub fn CSTL_string_data(instance: CSTL_StringRef) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the underlying null-terminated array\n serving as character storage.\n\n If `CSTL_string_empty(instance) == true` the pointer is still\n valid and points to a single null character.\n\n The range `[CSTL_string_c_str(instance), CSTL_string_c_str(instance) + size]`\n is always valid.\n"]
    pub fn CSTL_string_c_str(instance: CSTL_StringCRef) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) to the first character of the string.\n\n If `CSTL_string_empty(instance) == true` then\n `CSTL_string_begin(instance) == CSTL_string_end(instance)`.\n"]
    pub fn CSTL_string_begin(instance: CSTL_StringRef) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) past the last character of the string.\n\n If `CSTL_string_empty(instance) == true` then\n `CSTL_string_begin(instance) == CSTL_string_end(instance)`.\n"]
    pub fn CSTL_string_const_begin(instance: CSTL_StringCRef) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) past the last character of the string.\n\n If `CSTL_string_empty(instance) == true` then\n `CSTL_string_begin(instance) == CSTL_string_end(instance)`.\n"]
    pub fn CSTL_string_end(instance: CSTL_StringRef) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns a const iterator (pointer) past the last character of the string.\n\n If `CSTL_string_empty(instance) == true` then\n `CSTL_string_const_begin(instance) == CSTL_string_const_end(instance)`.\n"]
    pub fn CSTL_string_const_end(instance: CSTL_StringCRef) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the string is empty or `false` otherwise.\n"]
    pub fn CSTL_string_empty(instance: CSTL_StringCRef) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters in the string.\n"]
    pub fn CSTL_string_size(instance: CSTL_StringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters in the string.\n"]
    pub fn CSTL_string_length(instance: CSTL_StringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the total characters capacity of the string.\n"]
    pub fn CSTL_string_capacity(instance: CSTL_StringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the maximum possible number of characters in the string.\n"]
    pub fn CSTL_string_max_size() -> usize;
}
unsafe extern "C" {
    #[doc = " If `new_capacity > CSTL_string_capacity(instance)`, reallocates and expands\n the underlying array storage.\n\n If `new_capacity` exceeds `CSTL_string_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_reserve(
        instance: CSTL_StringRef,
        new_capacity: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Request removal of unused capacity.\n"]
    pub fn CSTL_string_shrink_to_fit(instance: CSTL_StringRef, alloc: *mut CSTL_Alloc);
}
unsafe extern "C" {
    #[doc = " Erase all characters from the string without affecting capacity.\n"]
    pub fn CSTL_string_clear(instance: CSTL_StringRef);
}
unsafe extern "C" {
    #[doc = " Inserts the null-terminated string at `ptr` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_string_insert(
        instance: CSTL_StringRef,
        where_: *const ::std::os::raw::c_char,
        ptr: *const ::std::os::raw::c_char,
        alloc: *mut CSTL_Alloc,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Inserts the first `count` characters of the string at `ptr` at the pointer  `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_string_insert_n(
        instance: CSTL_StringRef,
        where_: *const ::std::os::raw::c_char,
        ptr: *const ::std::os::raw::c_char,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Inserts `count` copies of the character `ch` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_string_insert_char(
        instance: CSTL_StringRef,
        where_: *const ::std::os::raw::c_char,
        count: usize,
        ch: ::std::os::raw::c_char,
        alloc: *mut CSTL_Alloc,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Inserts the string `other` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_string_insert_str(
        instance: CSTL_StringRef,
        where_: *const ::std::os::raw::c_char,
        other: CSTL_StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Inserts the substring at offset `other_off` in `other` with the length\n given by `count` at the pointer `where` in `instance`.\n\n If `other_off` is outside of the range `[other, other + CSTL_string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_string_insert_substr(
        instance: CSTL_StringRef,
        where_: *const ::std::os::raw::c_char,
        other: CSTL_StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Inserts the null-terminated string at `ptr` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_insert_at(
        instance: CSTL_StringRef,
        off: usize,
        ptr: *const ::std::os::raw::c_char,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the first `count` characters of the string at `ptr` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_insert_n_at(
        instance: CSTL_StringRef,
        off: usize,
        ptr: *const ::std::os::raw::c_char,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts `count` copies of the character `ch` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_insert_char_at(
        instance: CSTL_StringRef,
        off: usize,
        count: usize,
        ch: ::std::os::raw::c_char,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the string `other` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_insert_str_at(
        instance: CSTL_StringRef,
        off: usize,
        other: CSTL_StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the substring at offset `other_off` in `other` with the length\n given by `count` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_string_size(instance)]`\n or if `other_off` is outside of the range `[other, other + CSTL_string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_insert_substr_at(
        instance: CSTL_StringRef,
        off: usize,
        other: CSTL_StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Removes the character at `where` and returns a pointer following the\n removed character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_string_erase(
        instance: CSTL_StringRef,
        where_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Removes the characters in the range `[first, last)` and returns a pointer following the\n removed character.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_string_erase_substr(
        instance: CSTL_StringRef,
        first: *const ::std::os::raw::c_char,
        last: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Removes the character at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_string_size(instance)]`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_erase_at(instance: CSTL_StringRef, off: usize) -> bool;
}
unsafe extern "C" {
    #[doc = " Removes the substring at offset `off` in `instance` with the length given by `count`.\n\n If `off` is outside of the range `[instance, instance + CSTL_string_size(instance)]`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_erase_substr_at(instance: CSTL_StringRef, off: usize, count: usize) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the character `ch` to the end of the string.\n\n If `CSTL_string_size(instance) == CSTL_string_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_push_back(
        instance: CSTL_StringRef,
        ch: ::std::os::raw::c_char,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the character `ch` to the end of the string.\n\n If `CSTL_string_size(instance) == CSTL_string_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_pop_back(instance: CSTL_StringRef);
}
unsafe extern "C" {
    #[doc = " Appends the null-terminated string at `ptr` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_append(
        instance: CSTL_StringRef,
        ptr: *const ::std::os::raw::c_char,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the first `count` characters of the string at `ptr` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_append_n(
        instance: CSTL_StringRef,
        ptr: *const ::std::os::raw::c_char,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends `count` copies of the character `ch` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_append_char(
        instance: CSTL_StringRef,
        count: usize,
        ch: ::std::os::raw::c_char,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the string `other` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_append_str(
        instance: CSTL_StringRef,
        other: CSTL_StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the substring at offset `other_off` in `other` with the length\n given by `count` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_append_substr(
        instance: CSTL_StringRef,
        other: CSTL_StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the null-terminated\n string at `ptr`.\n\n If the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_string_replace(
        instance: CSTL_StringRef,
        first: *const ::std::os::raw::c_char,
        last: *const ::std::os::raw::c_char,
        ptr: *const ::std::os::raw::c_char,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the first `count`\n characters of the string at `ptr`.\n\n If the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_string_replace_n(
        instance: CSTL_StringRef,
        first: *const ::std::os::raw::c_char,
        last: *const ::std::os::raw::c_char,
        ptr: *const ::std::os::raw::c_char,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with `count` copies\n of the character `ch`.\n\n If the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_string_replace_char(
        instance: CSTL_StringRef,
        first: *const ::std::os::raw::c_char,
        last: *const ::std::os::raw::c_char,
        count: usize,
        ch: ::std::os::raw::c_char,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the string `other`.\n\n If the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_string_replace_str(
        instance: CSTL_StringRef,
        first: *const ::std::os::raw::c_char,
        last: *const ::std::os::raw::c_char,
        other: CSTL_StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the substring\n at offset `other_off` in `other` with the length given by `count`.\n\n If `other_off` is outside of the range `[other, other + CSTL_string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_string_replace_substr(
        instance: CSTL_StringRef,
        first: *const ::std::os::raw::c_char,
        last: *const ::std::os::raw::c_char,
        other: CSTL_StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the null-terminated string at `ptr`.\n\n If `off` is outside of the range `[instance, instance + CSTL_string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_replace_at(
        instance: CSTL_StringRef,
        off: usize,
        count: usize,
        ptr: *const ::std::os::raw::c_char,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the first `count2` characters of the string at `ptr`.\n\n If `off` is outside of the range `[instance, instance + CSTL_string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_replace_n_at(
        instance: CSTL_StringRef,
        off: usize,
        count: usize,
        ptr: *const ::std::os::raw::c_char,
        count2: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with `count` copies of the character `ch`.\n\n If `off` is outside of the range `[instance, instance + CSTL_string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_replace_char_at(
        instance: CSTL_StringRef,
        off: usize,
        count: usize,
        count2: usize,
        ch: ::std::os::raw::c_char,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the string `other`.\n\n If `off` is outside of the range `[instance, instance + CSTL_string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_replace_str_at(
        instance: CSTL_StringRef,
        off: usize,
        count: usize,
        other: CSTL_StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the substring at offset `other_off` in `other` with the length\n given by `count2`.\n\n If `off` is outside of the range `[instance, instance + CSTL_string_size(instance)]`\n or if `other_off` is outside of the range `[other, other + CSTL_string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_replace_substr_at(
        instance: CSTL_StringRef,
        off: usize,
        count: usize,
        other: CSTL_StringCRef,
        other_off: usize,
        count2: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Copies a substring `[off, off + count)` to character string pointed to by\n `dest`. The resulting character string is not null terminated.\n\n Returns the number of characters copied or `CSTL_string_npos` if\n `off > CSTL_string_size(instance)` (out of range).\n"]
    pub fn CSTL_string_copy(
        instance: CSTL_StringCRef,
        dest: *mut ::std::os::raw::c_char,
        count: usize,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Resizes the string to contain `new_size` characters, appending `ch`\n if current size is less than `new_size`.\n\n If `new_size` is greater than `CSTL_string_max_size()` this\n function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_string_resize(
        instance: CSTL_StringRef,
        new_size: usize,
        ch: ::std::os::raw::c_char,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the null-terminated string `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_string_find(
        instance: CSTL_StringCRef,
        ptr: *const ::std::os::raw::c_char,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the first `count` characters at `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_string_find_n(
        instance: CSTL_StringCRef,
        ptr: *const ::std::os::raw::c_char,
        off: usize,
        count: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` occurence of the character `ch`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_string_find_char(
        instance: CSTL_StringCRef,
        ch: ::std::os::raw::c_char,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the string `other`\n and return its position from the start of the original string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_string_find_str(
        instance: CSTL_StringCRef,
        other: CSTL_StringCRef,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the null-terminated string `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_string_rfind(
        instance: CSTL_StringCRef,
        ptr: *const ::std::os::raw::c_char,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the first `count` characters at `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_string_rfind_n(
        instance: CSTL_StringCRef,
        ptr: *const ::std::os::raw::c_char,
        off: usize,
        count: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` occurence of the character `ch`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_string_rfind_char(
        instance: CSTL_StringCRef,
        ch: ::std::os::raw::c_char,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the string `other`\n and return its position from the start of the original string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_string_rfind_str(
        instance: CSTL_StringCRef,
        other: CSTL_StringCRef,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Compare two null-terminated character sequences.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n There is no `CSTL_String` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_string_compare(
        left: *const ::std::os::raw::c_char,
        right: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compare an explicit length character sequence with a null-terminated one.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n To compare an explicit length `left` and a null-terminated `right`,\n swap them and negate the result: `-CSTL_string_compare_n(right, left, left_count)`.\n\n There is no `CSTL_String` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_string_compare_n(
        left: *const ::std::os::raw::c_char,
        right: *const ::std::os::raw::c_char,
        right_count: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compare two explicit length character sequences.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n There is no `CSTL_String` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_string_compare_nn(
        left: *const ::std::os::raw::c_char,
        left_count: usize,
        right: *const ::std::os::raw::c_char,
        right_count: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " STL ABI `std::basic_string` layout.\n\n Does not include the allocator, which nonetheless is a part of the `std::basic_string`\n structure! You are responsible for including it, since it can take on any form.\n\n Do not manipulate the members directly, use the associated functions!\n"]
#[repr(C)]
pub struct CSTL_WideStringVal {
    pub bx: CSTL_WideStringVal__bindgen_ty_1,
    pub size: usize,
    pub res: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CSTL_WideStringVal__bindgen_ty_1 {
    pub buf: [wchar_t; 8usize],
    pub ptr: *mut wchar_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_WideStringVal__bindgen_ty_1"]
        [::std::mem::size_of::<CSTL_WideStringVal__bindgen_ty_1>() - 16usize];
    ["Alignment of CSTL_WideStringVal__bindgen_ty_1"]
        [::std::mem::align_of::<CSTL_WideStringVal__bindgen_ty_1>() - 8usize];
    ["Offset of field: CSTL_WideStringVal__bindgen_ty_1::buf"]
        [::std::mem::offset_of!(CSTL_WideStringVal__bindgen_ty_1, buf) - 0usize];
    ["Offset of field: CSTL_WideStringVal__bindgen_ty_1::ptr"]
        [::std::mem::offset_of!(CSTL_WideStringVal__bindgen_ty_1, ptr) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_WideStringVal"][::std::mem::size_of::<CSTL_WideStringVal>() - 32usize];
    ["Alignment of CSTL_WideStringVal"][::std::mem::align_of::<CSTL_WideStringVal>() - 8usize];
    ["Offset of field: CSTL_WideStringVal::bx"]
        [::std::mem::offset_of!(CSTL_WideStringVal, bx) - 0usize];
    ["Offset of field: CSTL_WideStringVal::size"]
        [::std::mem::offset_of!(CSTL_WideStringVal, size) - 16usize];
    ["Offset of field: CSTL_WideStringVal::res"]
        [::std::mem::offset_of!(CSTL_WideStringVal, res) - 24usize];
};
#[doc = " Reference to a mutable `CSTL_WideStringVal`.\n\n Must not be null.\n"]
pub type CSTL_WideStringRef = *mut CSTL_WideStringVal;
#[doc = " Reference to a const `CSTL_WideStringVal`.\n\n Must not be null.\n"]
pub type CSTL_WideStringCRef = *const CSTL_WideStringVal;
unsafe extern "C" {
    #[doc = " Initializes the string, but does not allocate any memory.\n\n An initialized string can be trivially destroyed without leaks as long\n as its owned string is small enough to be inline (smaller than CSTL_string_alloc_mask).\n\n Re-initializing a string with a backing memory allocation will leak the old\n memory allocation.\n"]
    pub fn CSTL_wstring_construct(new_instance: *mut CSTL_WideStringVal);
}
unsafe extern "C" {
    #[doc = " Destroys the string, freeing the backing storage if necessary.\n"]
    pub fn CSTL_wstring_destroy(instance: CSTL_WideStringRef, alloc: *mut CSTL_Alloc);
}
unsafe extern "C" {
    #[doc = " Initializes the string with the substring at offset `other_off`\n in `other` with the length given by `count`.\n\n If `new_instance == NULL` or if `other_off` is outside of the range\n `[other, other + CSTL_wstring_size(other)]` returns `false` and does nothing,\n otherwise it returns `true`.\n\n If `new_instance == other` the substring operation is performed in-place without\n de-initializing `other`.\n\n Remember that re-initializing a different string with a backing memory allocation\n will leak the old memory allocation.\n"]
    pub fn CSTL_wstring_substr(
        new_instance: *mut CSTL_WideStringVal,
        other: CSTL_WideStringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the null-terminated string at `ptr`.\n\n If the length of the string at `ptr` is greater than `CSTL_wstring_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_assign(
        instance: CSTL_WideStringRef,
        ptr: *const wchar_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the first `count` characters of the string at `ptr`.\n\n If `n` is greater than `CSTL_wstring_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_assign_n(
        instance: CSTL_WideStringRef,
        ptr: *const wchar_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the `count` copies of the character `ch`.\n\n If `count` is greater than `CSTL_wstring_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_assign_char(
        instance: CSTL_WideStringRef,
        count: usize,
        ch: wchar_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the substring at offset `other_off` in `other`\n with the length given by `count`.\n\n If `other_off` is outside of the range `[other, other + CSTL_wstring_size(other)]` returns\n `false` and does nothing, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_assign_substr(
        instance: CSTL_WideStringRef,
        other: CSTL_WideStringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the contents of `other_instance`.\n\n If `propagate_alloc == true && alloc != other_alloc` then storage\n is freed with `alloc` and allocated again with `other_alloc` before contents\n are copied. Then, `instance` uses `other_alloc` as its allocator.\n\n If `propagate_alloc == false` `instance` keeps using `alloc` as its allocator,\n potentially reusing its storage.\n\n You are responsible for replacing the allocator outside of `CSTL_WideStringVal` if applicable.\n"]
    pub fn CSTL_wstring_copy_assign(
        instance: CSTL_WideStringRef,
        alloc: *mut CSTL_Alloc,
        other_instance: CSTL_WideStringCRef,
        other_alloc: *mut CSTL_Alloc,
        propagate_alloc: bool,
    );
}
unsafe extern "C" {
    #[doc = " Moves the contents of `other_instance` to the contents of `instance`.\n\n If `propagate_alloc == true` storage is replaced with storage of `other_instance`.\n Then, `instance` uses `other_alloc` as its allocator.\n\n If `propagate_alloc == false && alloc != other_alloc` then storage is reused\n and individual characters of `other` are moved in. Then, `instance` uses `alloc` as its allocator.\n\n You are responsible for replacing the allocator outside of `CSTL_WideStringVal` if applicable.\n"]
    pub fn CSTL_wstring_move_assign(
        instance: CSTL_WideStringRef,
        alloc: *mut CSTL_Alloc,
        other_instance: CSTL_WideStringRef,
        other_alloc: *mut CSTL_Alloc,
        propagate_alloc: bool,
    );
}
unsafe extern "C" {
    #[doc = " Swaps string contents.\n\n You are responsible for swapping the allocators.\n"]
    pub fn CSTL_wstring_swap(instance: CSTL_WideStringRef, other_instance: CSTL_WideStringRef);
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the character at `pos`.\n\n If `pos >= CSTL_wstring_length(instance)` the behavior is undefined.\n"]
    pub fn CSTL_wstring_index(instance: CSTL_WideStringRef, pos: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the character at `pos`.\n\n If `pos >= CSTL_wstring_length(instance)` the behavior is undefined.\n"]
    pub fn CSTL_wstring_const_index(instance: CSTL_WideStringCRef, pos: usize) -> *const wchar_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the character at `pos`.\n\n If `pos >= CSTL_wstring_length(instance)` a null pointer is returned.\n"]
    pub fn CSTL_wstring_at(instance: CSTL_WideStringRef, pos: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the character at `pos`.\n\n If `pos >= CSTL_wstring_length(instance)` a null pointer is returned.\n"]
    pub fn CSTL_wstring_const_at(instance: CSTL_WideStringCRef, pos: usize) -> *const wchar_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the first character.\n\n If `CSTL_wstring_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_wstring_front(instance: CSTL_WideStringRef) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the first character.\n\n If `CSTL_wstring_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_wstring_const_front(instance: CSTL_WideStringCRef) -> *const wchar_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the last character.\n\n If `CSTL_wstring_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_wstring_back(instance: CSTL_WideStringRef) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the last character.\n\n If `CSTL_wstring_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_wstring_const_back(instance: CSTL_WideStringCRef) -> *const wchar_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the underlying null-terminated array\n serving as character storage.\n\n If `CSTL_wstring_empty(instance) == true` the pointer is still\n valid and points to a single null character.\n\n The range `[CSTL_wstring_data(instance), CSTL_wstring_data(instance) + size]`\n is always valid.\n\n The array may be mutated through the returned pointer excluding\n the past-the-end null terminator.\n"]
    pub fn CSTL_wstring_data(instance: CSTL_WideStringRef) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the underlying null-terminated array\n serving as character storage.\n\n If `CSTL_wstring_empty(instance) == true` the pointer is still\n valid and points to a single null character.\n\n The range `[CSTL_wstring_c_str(instance), CSTL_wstring_c_str(instance) + size]`\n is always valid.\n"]
    pub fn CSTL_wstring_c_str(instance: CSTL_WideStringCRef) -> *const wchar_t;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) to the first character of the string.\n\n If `CSTL_wstring_empty(instance) == true` then\n `CSTL_wstring_begin(instance) == CSTL_wstring_end(instance)`.\n"]
    pub fn CSTL_wstring_begin(instance: CSTL_WideStringRef) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) past the last character of the string.\n\n If `CSTL_wstring_empty(instance) == true` then\n `CSTL_wstring_begin(instance) == CSTL_wstring_end(instance)`.\n"]
    pub fn CSTL_wstring_const_begin(instance: CSTL_WideStringCRef) -> *const wchar_t;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) past the last character of the string.\n\n If `CSTL_wstring_empty(instance) == true` then\n `CSTL_wstring_begin(instance) == CSTL_wstring_end(instance)`.\n"]
    pub fn CSTL_wstring_end(instance: CSTL_WideStringRef) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Returns a const iterator (pointer) past the last character of the string.\n\n If `CSTL_wstring_empty(instance) == true` then\n `CSTL_wstring_const_begin(instance) == CSTL_wstring_const_end(instance)`.\n"]
    pub fn CSTL_wstring_const_end(instance: CSTL_WideStringCRef) -> *const wchar_t;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the string is empty or `false` otherwise.\n"]
    pub fn CSTL_wstring_empty(instance: CSTL_WideStringCRef) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters in the string.\n"]
    pub fn CSTL_wstring_size(instance: CSTL_WideStringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters in the string.\n"]
    pub fn CSTL_wstring_length(instance: CSTL_WideStringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the total characters capacity of the string.\n"]
    pub fn CSTL_wstring_capacity(instance: CSTL_WideStringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the maximum possible number of characters in the string.\n"]
    pub fn CSTL_wstring_max_size() -> usize;
}
unsafe extern "C" {
    #[doc = " If `new_capacity > CSTL_wstring_capacity(instance)`, reallocates and expands\n the underlying array storage.\n\n If `new_capacity` exceeds `CSTL_wstring_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_reserve(
        instance: CSTL_WideStringRef,
        new_capacity: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Request removal of unused capacity.\n"]
    pub fn CSTL_wstring_shrink_to_fit(instance: CSTL_WideStringRef, alloc: *mut CSTL_Alloc);
}
unsafe extern "C" {
    #[doc = " Erase all characters from the string without affecting capacity.\n"]
    pub fn CSTL_wstring_clear(instance: CSTL_WideStringRef);
}
unsafe extern "C" {
    #[doc = " Inserts the null-terminated string at `ptr` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_wstring_insert(
        instance: CSTL_WideStringRef,
        where_: *const wchar_t,
        ptr: *const wchar_t,
        alloc: *mut CSTL_Alloc,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Inserts the first `count` characters of the string at `ptr` at the pointer  `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_wstring_insert_n(
        instance: CSTL_WideStringRef,
        where_: *const wchar_t,
        ptr: *const wchar_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Inserts `count` copies of the character `ch` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_wstring_insert_char(
        instance: CSTL_WideStringRef,
        where_: *const wchar_t,
        count: usize,
        ch: wchar_t,
        alloc: *mut CSTL_Alloc,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Inserts the string `other` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_wstring_insert_str(
        instance: CSTL_WideStringRef,
        where_: *const wchar_t,
        other: CSTL_WideStringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Inserts the substring at offset `other_off` in `other` with the length\n given by `count` at the pointer `where` in `instance`.\n\n If `other_off` is outside of the range `[other, other + CSTL_wstring_size(other)]`\n or if the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_wstring_insert_substr(
        instance: CSTL_WideStringRef,
        where_: *const wchar_t,
        other: CSTL_WideStringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Inserts the null-terminated string at `ptr` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_wstring_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_insert_at(
        instance: CSTL_WideStringRef,
        off: usize,
        ptr: *const wchar_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the first `count` characters of the string at `ptr` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_wstring_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_insert_n_at(
        instance: CSTL_WideStringRef,
        off: usize,
        ptr: *const wchar_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts `count` copies of the character `ch` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_wstring_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_insert_char_at(
        instance: CSTL_WideStringRef,
        off: usize,
        count: usize,
        ch: wchar_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the string `other` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_wstring_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_insert_str_at(
        instance: CSTL_WideStringRef,
        off: usize,
        other: CSTL_WideStringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the substring at offset `other_off` in `other` with the length\n given by `count` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_wstring_size(instance)]`\n or if `other_off` is outside of the range `[other, other + CSTL_wstring_size(other)]`\n or if the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_insert_substr_at(
        instance: CSTL_WideStringRef,
        off: usize,
        other: CSTL_WideStringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Removes the character at `where` and returns a pointer following the\n removed character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_wstring_erase(instance: CSTL_WideStringRef, where_: *const wchar_t)
        -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Removes the characters in the range `[first, last)` and returns a pointer following the\n removed character.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_wstring_erase_substr(
        instance: CSTL_WideStringRef,
        first: *const wchar_t,
        last: *const wchar_t,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Removes the character at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_wstring_size(instance)]`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_erase_at(instance: CSTL_WideStringRef, off: usize) -> bool;
}
unsafe extern "C" {
    #[doc = " Removes the substring at offset `off` in `instance` with the length given by `count`.\n\n If `off` is outside of the range `[instance, instance + CSTL_wstring_size(instance)]`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_erase_substr_at(
        instance: CSTL_WideStringRef,
        off: usize,
        count: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the character `ch` to the end of the string.\n\n If `CSTL_wstring_size(instance) == CSTL_wstring_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_push_back(
        instance: CSTL_WideStringRef,
        ch: wchar_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the character `ch` to the end of the string.\n\n If `CSTL_wstring_size(instance) == CSTL_wstring_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_pop_back(instance: CSTL_WideStringRef);
}
unsafe extern "C" {
    #[doc = " Appends the null-terminated string at `ptr` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_append(
        instance: CSTL_WideStringRef,
        ptr: *const wchar_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the first `count` characters of the string at `ptr` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_append_n(
        instance: CSTL_WideStringRef,
        ptr: *const wchar_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends `count` copies of the character `ch` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_append_char(
        instance: CSTL_WideStringRef,
        count: usize,
        ch: wchar_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the string `other` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_append_str(
        instance: CSTL_WideStringRef,
        other: CSTL_WideStringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the substring at offset `other_off` in `other` with the length\n given by `count` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_append_substr(
        instance: CSTL_WideStringRef,
        other: CSTL_WideStringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the null-terminated\n string at `ptr`.\n\n If the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_wstring_replace(
        instance: CSTL_WideStringRef,
        first: *const wchar_t,
        last: *const wchar_t,
        ptr: *const wchar_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the first `count`\n characters of the string at `ptr`.\n\n If the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_wstring_replace_n(
        instance: CSTL_WideStringRef,
        first: *const wchar_t,
        last: *const wchar_t,
        ptr: *const wchar_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with `count` copies\n of the character `ch`.\n\n If the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_wstring_replace_char(
        instance: CSTL_WideStringRef,
        first: *const wchar_t,
        last: *const wchar_t,
        count: usize,
        ch: wchar_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the string `other`.\n\n If the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_wstring_replace_str(
        instance: CSTL_WideStringRef,
        first: *const wchar_t,
        last: *const wchar_t,
        other: CSTL_WideStringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the substring\n at offset `other_off` in `other` with the length given by `count`.\n\n If `other_off` is outside of the range `[other, other + CSTL_wstring_size(other)]`\n or if the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_wstring_replace_substr(
        instance: CSTL_WideStringRef,
        first: *const wchar_t,
        last: *const wchar_t,
        other: CSTL_WideStringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the null-terminated string at `ptr`.\n\n If `off` is outside of the range `[instance, instance + CSTL_wstring_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_replace_at(
        instance: CSTL_WideStringRef,
        off: usize,
        count: usize,
        ptr: *const wchar_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the first `count2` characters of the string at `ptr`.\n\n If `off` is outside of the range `[instance, instance + CSTL_wstring_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_replace_n_at(
        instance: CSTL_WideStringRef,
        off: usize,
        count: usize,
        ptr: *const wchar_t,
        count2: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with `count` copies of the character `ch`.\n\n If `off` is outside of the range `[instance, instance + CSTL_wstring_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_replace_char_at(
        instance: CSTL_WideStringRef,
        off: usize,
        count: usize,
        count2: usize,
        ch: wchar_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the string `other`.\n\n If `off` is outside of the range `[instance, instance + CSTL_wstring_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_replace_str_at(
        instance: CSTL_WideStringRef,
        off: usize,
        count: usize,
        other: CSTL_WideStringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the substring at offset `other_off` in `other` with the length\n given by `count2`.\n\n If `off` is outside of the range `[instance, instance + CSTL_wstring_size(instance)]`\n or if `other_off` is outside of the range `[other, other + CSTL_wstring_size(other)]`\n or if the length of the resulting string is greater than `CSTL_wstring_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_replace_substr_at(
        instance: CSTL_WideStringRef,
        off: usize,
        count: usize,
        other: CSTL_WideStringCRef,
        other_off: usize,
        count2: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Copies a substring `[off, off + count)` to character string pointed to by\n `dest`. The resulting character string is not null terminated.\n\n Returns the number of characters copied or `CSTL_string_npos` if\n `off > CSTL_wstring_size(instance)` (out of range).\n"]
    pub fn CSTL_wstring_copy(
        instance: CSTL_WideStringCRef,
        dest: *mut wchar_t,
        count: usize,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Resizes the string to contain `new_size` characters, appending `ch`\n if current size is less than `new_size`.\n\n If `new_size` is greater than `CSTL_wstring_max_size()` this\n function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_wstring_resize(
        instance: CSTL_WideStringRef,
        new_size: usize,
        ch: wchar_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the null-terminated string `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_wstring_find(
        instance: CSTL_WideStringCRef,
        ptr: *const wchar_t,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the first `count` characters at `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_wstring_find_n(
        instance: CSTL_WideStringCRef,
        ptr: *const wchar_t,
        off: usize,
        count: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` occurence of the character `ch`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_wstring_find_char(instance: CSTL_WideStringCRef, ch: wchar_t, off: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the string `other`\n and return its position from the start of the original string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_wstring_find_str(
        instance: CSTL_WideStringCRef,
        other: CSTL_WideStringCRef,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the null-terminated string `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_wstring_rfind(
        instance: CSTL_WideStringCRef,
        ptr: *const wchar_t,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the first `count` characters at `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_wstring_rfind_n(
        instance: CSTL_WideStringCRef,
        ptr: *const wchar_t,
        off: usize,
        count: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` occurence of the character `ch`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_wstring_rfind_char(instance: CSTL_WideStringCRef, ch: wchar_t, off: usize)
        -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the string `other`\n and return its position from the start of the original string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_wstring_rfind_str(
        instance: CSTL_WideStringCRef,
        other: CSTL_WideStringCRef,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Compare two null-terminated character sequences.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n There is no `CSTL_WideString` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_wstring_compare(
        left: *const wchar_t,
        right: *const wchar_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compare an explicit length character sequence with a null-terminated one.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n To compare an explicit length `left` and a null-terminated `right`,\n swap them and negate the result: `-CSTL_wstring_compare_n(right, left, left_count)`.\n\n There is no `CSTL_WideString` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_wstring_compare_n(
        left: *const wchar_t,
        right: *const wchar_t,
        right_count: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compare two explicit length character sequences.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n There is no `CSTL_WideString` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_wstring_compare_nn(
        left: *const wchar_t,
        left_count: usize,
        right: *const wchar_t,
        right_count: usize,
    ) -> ::std::os::raw::c_int;
}
pub type char16_t = ::std::os::raw::c_ushort;
pub type char32_t = ::std::os::raw::c_uint;
pub type char8_t = ::std::os::raw::c_uchar;
#[doc = " STL ABI `std::basic_string` layout.\n\n Does not include the allocator, which nonetheless is a part of the `std::basic_string`\n structure! You are responsible for including it, since it can take on any form.\n\n Do not manipulate the members directly, use the associated functions!\n"]
#[repr(C)]
pub struct CSTL_UTF8StringVal {
    pub bx: CSTL_UTF8StringVal__bindgen_ty_1,
    pub size: usize,
    pub res: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CSTL_UTF8StringVal__bindgen_ty_1 {
    pub buf: [char8_t; 16usize],
    pub ptr: *mut char8_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_UTF8StringVal__bindgen_ty_1"]
        [::std::mem::size_of::<CSTL_UTF8StringVal__bindgen_ty_1>() - 16usize];
    ["Alignment of CSTL_UTF8StringVal__bindgen_ty_1"]
        [::std::mem::align_of::<CSTL_UTF8StringVal__bindgen_ty_1>() - 8usize];
    ["Offset of field: CSTL_UTF8StringVal__bindgen_ty_1::buf"]
        [::std::mem::offset_of!(CSTL_UTF8StringVal__bindgen_ty_1, buf) - 0usize];
    ["Offset of field: CSTL_UTF8StringVal__bindgen_ty_1::ptr"]
        [::std::mem::offset_of!(CSTL_UTF8StringVal__bindgen_ty_1, ptr) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_UTF8StringVal"][::std::mem::size_of::<CSTL_UTF8StringVal>() - 32usize];
    ["Alignment of CSTL_UTF8StringVal"][::std::mem::align_of::<CSTL_UTF8StringVal>() - 8usize];
    ["Offset of field: CSTL_UTF8StringVal::bx"]
        [::std::mem::offset_of!(CSTL_UTF8StringVal, bx) - 0usize];
    ["Offset of field: CSTL_UTF8StringVal::size"]
        [::std::mem::offset_of!(CSTL_UTF8StringVal, size) - 16usize];
    ["Offset of field: CSTL_UTF8StringVal::res"]
        [::std::mem::offset_of!(CSTL_UTF8StringVal, res) - 24usize];
};
#[doc = " Reference to a mutable `CSTL_UTF8StringVal`.\n\n Must not be null.\n"]
pub type CSTL_UTF8StringRef = *mut CSTL_UTF8StringVal;
#[doc = " Reference to a const `CSTL_UTF8StringVal`.\n\n Must not be null.\n"]
pub type CSTL_UTF8StringCRef = *const CSTL_UTF8StringVal;
unsafe extern "C" {
    #[doc = " Initializes the string, but does not allocate any memory.\n\n An initialized string can be trivially destroyed without leaks as long\n as its owned string is small enough to be inline (smaller than CSTL_string_alloc_mask).\n\n Re-initializing a string with a backing memory allocation will leak the old\n memory allocation.\n"]
    pub fn CSTL_u8string_construct(new_instance: *mut CSTL_UTF8StringVal);
}
unsafe extern "C" {
    #[doc = " Destroys the string, freeing the backing storage if necessary.\n"]
    pub fn CSTL_u8string_destroy(instance: CSTL_UTF8StringRef, alloc: *mut CSTL_Alloc);
}
unsafe extern "C" {
    #[doc = " Initializes the string with the substring at offset `other_off`\n in `other` with the length given by `count`.\n\n If `new_instance == NULL` or if `other_off` is outside of the range\n `[other, other + CSTL_u8string_size(other)]` returns `false` and does nothing,\n otherwise it returns `true`.\n\n If `new_instance == other` the substring operation is performed in-place without\n de-initializing `other`.\n\n Remember that re-initializing a different string with a backing memory allocation\n will leak the old memory allocation.\n"]
    pub fn CSTL_u8string_substr(
        new_instance: *mut CSTL_UTF8StringVal,
        other: CSTL_UTF8StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the null-terminated string at `ptr`.\n\n If the length of the string at `ptr` is greater than `CSTL_u8string_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_assign(
        instance: CSTL_UTF8StringRef,
        ptr: *const char8_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the first `count` characters of the string at `ptr`.\n\n If `n` is greater than `CSTL_u8string_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_assign_n(
        instance: CSTL_UTF8StringRef,
        ptr: *const char8_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the `count` copies of the character `ch`.\n\n If `count` is greater than `CSTL_u8string_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_assign_char(
        instance: CSTL_UTF8StringRef,
        count: usize,
        ch: char8_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the substring at offset `other_off` in `other`\n with the length given by `count`.\n\n If `other_off` is outside of the range `[other, other + CSTL_u8string_size(other)]` returns\n `false` and does nothing, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_assign_substr(
        instance: CSTL_UTF8StringRef,
        other: CSTL_UTF8StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the contents of `other_instance`.\n\n If `propagate_alloc == true && alloc != other_alloc` then storage\n is freed with `alloc` and allocated again with `other_alloc` before contents\n are copied. Then, `instance` uses `other_alloc` as its allocator.\n\n If `propagate_alloc == false` `instance` keeps using `alloc` as its allocator,\n potentially reusing its storage.\n\n You are responsible for replacing the allocator outside of `CSTL_UTF8StringVal` if applicable.\n"]
    pub fn CSTL_u8string_copy_assign(
        instance: CSTL_UTF8StringRef,
        alloc: *mut CSTL_Alloc,
        other_instance: CSTL_UTF8StringCRef,
        other_alloc: *mut CSTL_Alloc,
        propagate_alloc: bool,
    );
}
unsafe extern "C" {
    #[doc = " Moves the contents of `other_instance` to the contents of `instance`.\n\n If `propagate_alloc == true` storage is replaced with storage of `other_instance`.\n Then, `instance` uses `other_alloc` as its allocator.\n\n If `propagate_alloc == false && alloc != other_alloc` then storage is reused\n and individual characters of `other` are moved in. Then, `instance` uses `alloc` as its allocator.\n\n You are responsible for replacing the allocator outside of `CSTL_UTF8StringVal` if applicable.\n"]
    pub fn CSTL_u8string_move_assign(
        instance: CSTL_UTF8StringRef,
        alloc: *mut CSTL_Alloc,
        other_instance: CSTL_UTF8StringRef,
        other_alloc: *mut CSTL_Alloc,
        propagate_alloc: bool,
    );
}
unsafe extern "C" {
    #[doc = " Swaps string contents.\n\n You are responsible for swapping the allocators.\n"]
    pub fn CSTL_u8string_swap(instance: CSTL_UTF8StringRef, other_instance: CSTL_UTF8StringRef);
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the character at `pos`.\n\n If `pos >= CSTL_u8string_length(instance)` the behavior is undefined.\n"]
    pub fn CSTL_u8string_index(instance: CSTL_UTF8StringRef, pos: usize) -> *mut char8_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the character at `pos`.\n\n If `pos >= CSTL_u8string_length(instance)` the behavior is undefined.\n"]
    pub fn CSTL_u8string_const_index(instance: CSTL_UTF8StringCRef, pos: usize) -> *const char8_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the character at `pos`.\n\n If `pos >= CSTL_u8string_length(instance)` a null pointer is returned.\n"]
    pub fn CSTL_u8string_at(instance: CSTL_UTF8StringRef, pos: usize) -> *mut char8_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the character at `pos`.\n\n If `pos >= CSTL_u8string_length(instance)` a null pointer is returned.\n"]
    pub fn CSTL_u8string_const_at(instance: CSTL_UTF8StringCRef, pos: usize) -> *const char8_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the first character.\n\n If `CSTL_u8string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_u8string_front(instance: CSTL_UTF8StringRef) -> *mut char8_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the first character.\n\n If `CSTL_u8string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_u8string_const_front(instance: CSTL_UTF8StringCRef) -> *const char8_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the last character.\n\n If `CSTL_u8string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_u8string_back(instance: CSTL_UTF8StringRef) -> *mut char8_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the last character.\n\n If `CSTL_u8string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_u8string_const_back(instance: CSTL_UTF8StringCRef) -> *const char8_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the underlying null-terminated array\n serving as character storage.\n\n If `CSTL_u8string_empty(instance) == true` the pointer is still\n valid and points to a single null character.\n\n The range `[CSTL_u8string_data(instance), CSTL_u8string_data(instance) + size]`\n is always valid.\n\n The array may be mutated through the returned pointer excluding\n the past-the-end null terminator.\n"]
    pub fn CSTL_u8string_data(instance: CSTL_UTF8StringRef) -> *mut char8_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the underlying null-terminated array\n serving as character storage.\n\n If `CSTL_u8string_empty(instance) == true` the pointer is still\n valid and points to a single null character.\n\n The range `[CSTL_u8string_c_str(instance), CSTL_u8string_c_str(instance) + size]`\n is always valid.\n"]
    pub fn CSTL_u8string_c_str(instance: CSTL_UTF8StringCRef) -> *const char8_t;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) to the first character of the string.\n\n If `CSTL_u8string_empty(instance) == true` then\n `CSTL_u8string_begin(instance) == CSTL_u8string_end(instance)`.\n"]
    pub fn CSTL_u8string_begin(instance: CSTL_UTF8StringRef) -> *mut char8_t;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) past the last character of the string.\n\n If `CSTL_u8string_empty(instance) == true` then\n `CSTL_u8string_begin(instance) == CSTL_u8string_end(instance)`.\n"]
    pub fn CSTL_u8string_const_begin(instance: CSTL_UTF8StringCRef) -> *const char8_t;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) past the last character of the string.\n\n If `CSTL_u8string_empty(instance) == true` then\n `CSTL_u8string_begin(instance) == CSTL_u8string_end(instance)`.\n"]
    pub fn CSTL_u8string_end(instance: CSTL_UTF8StringRef) -> *mut char8_t;
}
unsafe extern "C" {
    #[doc = " Returns a const iterator (pointer) past the last character of the string.\n\n If `CSTL_u8string_empty(instance) == true` then\n `CSTL_u8string_const_begin(instance) == CSTL_u8string_const_end(instance)`.\n"]
    pub fn CSTL_u8string_const_end(instance: CSTL_UTF8StringCRef) -> *const char8_t;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the string is empty or `false` otherwise.\n"]
    pub fn CSTL_u8string_empty(instance: CSTL_UTF8StringCRef) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters in the string.\n"]
    pub fn CSTL_u8string_size(instance: CSTL_UTF8StringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters in the string.\n"]
    pub fn CSTL_u8string_length(instance: CSTL_UTF8StringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the total characters capacity of the string.\n"]
    pub fn CSTL_u8string_capacity(instance: CSTL_UTF8StringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the maximum possible number of characters in the string.\n"]
    pub fn CSTL_u8string_max_size() -> usize;
}
unsafe extern "C" {
    #[doc = " If `new_capacity > CSTL_u8string_capacity(instance)`, reallocates and expands\n the underlying array storage.\n\n If `new_capacity` exceeds `CSTL_u8string_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_reserve(
        instance: CSTL_UTF8StringRef,
        new_capacity: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Request removal of unused capacity.\n"]
    pub fn CSTL_u8string_shrink_to_fit(instance: CSTL_UTF8StringRef, alloc: *mut CSTL_Alloc);
}
unsafe extern "C" {
    #[doc = " Erase all characters from the string without affecting capacity.\n"]
    pub fn CSTL_u8string_clear(instance: CSTL_UTF8StringRef);
}
unsafe extern "C" {
    #[doc = " Inserts the null-terminated string at `ptr` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u8string_insert(
        instance: CSTL_UTF8StringRef,
        where_: *const char8_t,
        ptr: *const char8_t,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char8_t;
}
unsafe extern "C" {
    #[doc = " Inserts the first `count` characters of the string at `ptr` at the pointer  `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u8string_insert_n(
        instance: CSTL_UTF8StringRef,
        where_: *const char8_t,
        ptr: *const char8_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char8_t;
}
unsafe extern "C" {
    #[doc = " Inserts `count` copies of the character `ch` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u8string_insert_char(
        instance: CSTL_UTF8StringRef,
        where_: *const char8_t,
        count: usize,
        ch: char8_t,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char8_t;
}
unsafe extern "C" {
    #[doc = " Inserts the string `other` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u8string_insert_str(
        instance: CSTL_UTF8StringRef,
        where_: *const char8_t,
        other: CSTL_UTF8StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char8_t;
}
unsafe extern "C" {
    #[doc = " Inserts the substring at offset `other_off` in `other` with the length\n given by `count` at the pointer `where` in `instance`.\n\n If `other_off` is outside of the range `[other, other + CSTL_u8string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u8string_insert_substr(
        instance: CSTL_UTF8StringRef,
        where_: *const char8_t,
        other: CSTL_UTF8StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char8_t;
}
unsafe extern "C" {
    #[doc = " Inserts the null-terminated string at `ptr` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u8string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_insert_at(
        instance: CSTL_UTF8StringRef,
        off: usize,
        ptr: *const char8_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the first `count` characters of the string at `ptr` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u8string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_insert_n_at(
        instance: CSTL_UTF8StringRef,
        off: usize,
        ptr: *const char8_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts `count` copies of the character `ch` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u8string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_insert_char_at(
        instance: CSTL_UTF8StringRef,
        off: usize,
        count: usize,
        ch: char8_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the string `other` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u8string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_insert_str_at(
        instance: CSTL_UTF8StringRef,
        off: usize,
        other: CSTL_UTF8StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the substring at offset `other_off` in `other` with the length\n given by `count` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u8string_size(instance)]`\n or if `other_off` is outside of the range `[other, other + CSTL_u8string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_insert_substr_at(
        instance: CSTL_UTF8StringRef,
        off: usize,
        other: CSTL_UTF8StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Removes the character at `where` and returns a pointer following the\n removed character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u8string_erase(
        instance: CSTL_UTF8StringRef,
        where_: *const char8_t,
    ) -> *mut char8_t;
}
unsafe extern "C" {
    #[doc = " Removes the characters in the range `[first, last)` and returns a pointer following the\n removed character.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u8string_erase_substr(
        instance: CSTL_UTF8StringRef,
        first: *const char8_t,
        last: *const char8_t,
    ) -> *mut char8_t;
}
unsafe extern "C" {
    #[doc = " Removes the character at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u8string_size(instance)]`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_erase_at(instance: CSTL_UTF8StringRef, off: usize) -> bool;
}
unsafe extern "C" {
    #[doc = " Removes the substring at offset `off` in `instance` with the length given by `count`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u8string_size(instance)]`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_erase_substr_at(
        instance: CSTL_UTF8StringRef,
        off: usize,
        count: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the character `ch` to the end of the string.\n\n If `CSTL_u8string_size(instance) == CSTL_u8string_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_push_back(
        instance: CSTL_UTF8StringRef,
        ch: char8_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the character `ch` to the end of the string.\n\n If `CSTL_u8string_size(instance) == CSTL_u8string_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_pop_back(instance: CSTL_UTF8StringRef);
}
unsafe extern "C" {
    #[doc = " Appends the null-terminated string at `ptr` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_append(
        instance: CSTL_UTF8StringRef,
        ptr: *const char8_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the first `count` characters of the string at `ptr` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_append_n(
        instance: CSTL_UTF8StringRef,
        ptr: *const char8_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends `count` copies of the character `ch` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_append_char(
        instance: CSTL_UTF8StringRef,
        count: usize,
        ch: char8_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the string `other` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_append_str(
        instance: CSTL_UTF8StringRef,
        other: CSTL_UTF8StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the substring at offset `other_off` in `other` with the length\n given by `count` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_append_substr(
        instance: CSTL_UTF8StringRef,
        other: CSTL_UTF8StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the null-terminated\n string at `ptr`.\n\n If the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u8string_replace(
        instance: CSTL_UTF8StringRef,
        first: *const char8_t,
        last: *const char8_t,
        ptr: *const char8_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the first `count`\n characters of the string at `ptr`.\n\n If the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u8string_replace_n(
        instance: CSTL_UTF8StringRef,
        first: *const char8_t,
        last: *const char8_t,
        ptr: *const char8_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with `count` copies\n of the character `ch`.\n\n If the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u8string_replace_char(
        instance: CSTL_UTF8StringRef,
        first: *const char8_t,
        last: *const char8_t,
        count: usize,
        ch: char8_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the string `other`.\n\n If the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u8string_replace_str(
        instance: CSTL_UTF8StringRef,
        first: *const char8_t,
        last: *const char8_t,
        other: CSTL_UTF8StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the substring\n at offset `other_off` in `other` with the length given by `count`.\n\n If `other_off` is outside of the range `[other, other + CSTL_u8string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u8string_replace_substr(
        instance: CSTL_UTF8StringRef,
        first: *const char8_t,
        last: *const char8_t,
        other: CSTL_UTF8StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the null-terminated string at `ptr`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u8string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_replace_at(
        instance: CSTL_UTF8StringRef,
        off: usize,
        count: usize,
        ptr: *const char8_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the first `count2` characters of the string at `ptr`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u8string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_replace_n_at(
        instance: CSTL_UTF8StringRef,
        off: usize,
        count: usize,
        ptr: *const char8_t,
        count2: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with `count` copies of the character `ch`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u8string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_replace_char_at(
        instance: CSTL_UTF8StringRef,
        off: usize,
        count: usize,
        count2: usize,
        ch: char8_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the string `other`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u8string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_replace_str_at(
        instance: CSTL_UTF8StringRef,
        off: usize,
        count: usize,
        other: CSTL_UTF8StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the substring at offset `other_off` in `other` with the length\n given by `count2`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u8string_size(instance)]`\n or if `other_off` is outside of the range `[other, other + CSTL_u8string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_u8string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_replace_substr_at(
        instance: CSTL_UTF8StringRef,
        off: usize,
        count: usize,
        other: CSTL_UTF8StringCRef,
        other_off: usize,
        count2: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Copies a substring `[off, off + count)` to character string pointed to by\n `dest`. The resulting character string is not null terminated.\n\n Returns the number of characters copied or `CSTL_string_npos` if\n `off > CSTL_u8string_size(instance)` (out of range).\n"]
    pub fn CSTL_u8string_copy(
        instance: CSTL_UTF8StringCRef,
        dest: *mut char8_t,
        count: usize,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Resizes the string to contain `new_size` characters, appending `ch`\n if current size is less than `new_size`.\n\n If `new_size` is greater than `CSTL_u8string_max_size()` this\n function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u8string_resize(
        instance: CSTL_UTF8StringRef,
        new_size: usize,
        ch: char8_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the null-terminated string `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u8string_find(
        instance: CSTL_UTF8StringCRef,
        ptr: *const char8_t,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the first `count` characters at `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u8string_find_n(
        instance: CSTL_UTF8StringCRef,
        ptr: *const char8_t,
        off: usize,
        count: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` occurence of the character `ch`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u8string_find_char(instance: CSTL_UTF8StringCRef, ch: char8_t, off: usize)
        -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the string `other`\n and return its position from the start of the original string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u8string_find_str(
        instance: CSTL_UTF8StringCRef,
        other: CSTL_UTF8StringCRef,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the null-terminated string `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u8string_rfind(
        instance: CSTL_UTF8StringCRef,
        ptr: *const char8_t,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the first `count` characters at `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u8string_rfind_n(
        instance: CSTL_UTF8StringCRef,
        ptr: *const char8_t,
        off: usize,
        count: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` occurence of the character `ch`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u8string_rfind_char(
        instance: CSTL_UTF8StringCRef,
        ch: char8_t,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the string `other`\n and return its position from the start of the original string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u8string_rfind_str(
        instance: CSTL_UTF8StringCRef,
        other: CSTL_UTF8StringCRef,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Compare two null-terminated character sequences.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n There is no `CSTL_UTF8String` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_u8string_compare(
        left: *const char8_t,
        right: *const char8_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compare an explicit length character sequence with a null-terminated one.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n To compare an explicit length `left` and a null-terminated `right`,\n swap them and negate the result: `-CSTL_u8string_compare_n(right, left, left_count)`.\n\n There is no `CSTL_UTF8String` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_u8string_compare_n(
        left: *const char8_t,
        right: *const char8_t,
        right_count: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compare two explicit length character sequences.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n There is no `CSTL_UTF8String` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_u8string_compare_nn(
        left: *const char8_t,
        left_count: usize,
        right: *const char8_t,
        right_count: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " STL ABI `std::basic_string` layout.\n\n Does not include the allocator, which nonetheless is a part of the `std::basic_string`\n structure! You are responsible for including it, since it can take on any form.\n\n Do not manipulate the members directly, use the associated functions!\n"]
#[repr(C)]
pub struct CSTL_UTF16StringVal {
    pub bx: CSTL_UTF16StringVal__bindgen_ty_1,
    pub size: usize,
    pub res: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CSTL_UTF16StringVal__bindgen_ty_1 {
    pub buf: [char16_t; 8usize],
    pub ptr: *mut char16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_UTF16StringVal__bindgen_ty_1"]
        [::std::mem::size_of::<CSTL_UTF16StringVal__bindgen_ty_1>() - 16usize];
    ["Alignment of CSTL_UTF16StringVal__bindgen_ty_1"]
        [::std::mem::align_of::<CSTL_UTF16StringVal__bindgen_ty_1>() - 8usize];
    ["Offset of field: CSTL_UTF16StringVal__bindgen_ty_1::buf"]
        [::std::mem::offset_of!(CSTL_UTF16StringVal__bindgen_ty_1, buf) - 0usize];
    ["Offset of field: CSTL_UTF16StringVal__bindgen_ty_1::ptr"]
        [::std::mem::offset_of!(CSTL_UTF16StringVal__bindgen_ty_1, ptr) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_UTF16StringVal"][::std::mem::size_of::<CSTL_UTF16StringVal>() - 32usize];
    ["Alignment of CSTL_UTF16StringVal"][::std::mem::align_of::<CSTL_UTF16StringVal>() - 8usize];
    ["Offset of field: CSTL_UTF16StringVal::bx"]
        [::std::mem::offset_of!(CSTL_UTF16StringVal, bx) - 0usize];
    ["Offset of field: CSTL_UTF16StringVal::size"]
        [::std::mem::offset_of!(CSTL_UTF16StringVal, size) - 16usize];
    ["Offset of field: CSTL_UTF16StringVal::res"]
        [::std::mem::offset_of!(CSTL_UTF16StringVal, res) - 24usize];
};
#[doc = " Reference to a mutable `CSTL_UTF16StringVal`.\n\n Must not be null.\n"]
pub type CSTL_UTF16StringRef = *mut CSTL_UTF16StringVal;
#[doc = " Reference to a const `CSTL_UTF16StringVal`.\n\n Must not be null.\n"]
pub type CSTL_UTF16StringCRef = *const CSTL_UTF16StringVal;
unsafe extern "C" {
    #[doc = " Initializes the string, but does not allocate any memory.\n\n An initialized string can be trivially destroyed without leaks as long\n as its owned string is small enough to be inline (smaller than CSTL_string_alloc_mask).\n\n Re-initializing a string with a backing memory allocation will leak the old\n memory allocation.\n"]
    pub fn CSTL_u16string_construct(new_instance: *mut CSTL_UTF16StringVal);
}
unsafe extern "C" {
    #[doc = " Destroys the string, freeing the backing storage if necessary.\n"]
    pub fn CSTL_u16string_destroy(instance: CSTL_UTF16StringRef, alloc: *mut CSTL_Alloc);
}
unsafe extern "C" {
    #[doc = " Initializes the string with the substring at offset `other_off`\n in `other` with the length given by `count`.\n\n If `new_instance == NULL` or if `other_off` is outside of the range\n `[other, other + CSTL_u16string_size(other)]` returns `false` and does nothing,\n otherwise it returns `true`.\n\n If `new_instance == other` the substring operation is performed in-place without\n de-initializing `other`.\n\n Remember that re-initializing a different string with a backing memory allocation\n will leak the old memory allocation.\n"]
    pub fn CSTL_u16string_substr(
        new_instance: *mut CSTL_UTF16StringVal,
        other: CSTL_UTF16StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the null-terminated string at `ptr`.\n\n If the length of the string at `ptr` is greater than `CSTL_u16string_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_assign(
        instance: CSTL_UTF16StringRef,
        ptr: *const char16_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the first `count` characters of the string at `ptr`.\n\n If `n` is greater than `CSTL_u16string_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_assign_n(
        instance: CSTL_UTF16StringRef,
        ptr: *const char16_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the `count` copies of the character `ch`.\n\n If `count` is greater than `CSTL_u16string_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_assign_char(
        instance: CSTL_UTF16StringRef,
        count: usize,
        ch: char16_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the substring at offset `other_off` in `other`\n with the length given by `count`.\n\n If `other_off` is outside of the range `[other, other + CSTL_u16string_size(other)]` returns\n `false` and does nothing, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_assign_substr(
        instance: CSTL_UTF16StringRef,
        other: CSTL_UTF16StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the contents of `other_instance`.\n\n If `propagate_alloc == true && alloc != other_alloc` then storage\n is freed with `alloc` and allocated again with `other_alloc` before contents\n are copied. Then, `instance` uses `other_alloc` as its allocator.\n\n If `propagate_alloc == false` `instance` keeps using `alloc` as its allocator,\n potentially reusing its storage.\n\n You are responsible for replacing the allocator outside of `CSTL_UTF16StringVal` if applicable.\n"]
    pub fn CSTL_u16string_copy_assign(
        instance: CSTL_UTF16StringRef,
        alloc: *mut CSTL_Alloc,
        other_instance: CSTL_UTF16StringCRef,
        other_alloc: *mut CSTL_Alloc,
        propagate_alloc: bool,
    );
}
unsafe extern "C" {
    #[doc = " Moves the contents of `other_instance` to the contents of `instance`.\n\n If `propagate_alloc == true` storage is replaced with storage of `other_instance`.\n Then, `instance` uses `other_alloc` as its allocator.\n\n If `propagate_alloc == false && alloc != other_alloc` then storage is reused\n and individual characters of `other` are moved in. Then, `instance` uses `alloc` as its allocator.\n\n You are responsible for replacing the allocator outside of `CSTL_UTF16StringVal` if applicable.\n"]
    pub fn CSTL_u16string_move_assign(
        instance: CSTL_UTF16StringRef,
        alloc: *mut CSTL_Alloc,
        other_instance: CSTL_UTF16StringRef,
        other_alloc: *mut CSTL_Alloc,
        propagate_alloc: bool,
    );
}
unsafe extern "C" {
    #[doc = " Swaps string contents.\n\n You are responsible for swapping the allocators.\n"]
    pub fn CSTL_u16string_swap(instance: CSTL_UTF16StringRef, other_instance: CSTL_UTF16StringRef);
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the character at `pos`.\n\n If `pos >= CSTL_u16string_length(instance)` the behavior is undefined.\n"]
    pub fn CSTL_u16string_index(instance: CSTL_UTF16StringRef, pos: usize) -> *mut char16_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the character at `pos`.\n\n If `pos >= CSTL_u16string_length(instance)` the behavior is undefined.\n"]
    pub fn CSTL_u16string_const_index(
        instance: CSTL_UTF16StringCRef,
        pos: usize,
    ) -> *const char16_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the character at `pos`.\n\n If `pos >= CSTL_u16string_length(instance)` a null pointer is returned.\n"]
    pub fn CSTL_u16string_at(instance: CSTL_UTF16StringRef, pos: usize) -> *mut char16_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the character at `pos`.\n\n If `pos >= CSTL_u16string_length(instance)` a null pointer is returned.\n"]
    pub fn CSTL_u16string_const_at(instance: CSTL_UTF16StringCRef, pos: usize) -> *const char16_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the first character.\n\n If `CSTL_u16string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_u16string_front(instance: CSTL_UTF16StringRef) -> *mut char16_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the first character.\n\n If `CSTL_u16string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_u16string_const_front(instance: CSTL_UTF16StringCRef) -> *const char16_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the last character.\n\n If `CSTL_u16string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_u16string_back(instance: CSTL_UTF16StringRef) -> *mut char16_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the last character.\n\n If `CSTL_u16string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_u16string_const_back(instance: CSTL_UTF16StringCRef) -> *const char16_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the underlying null-terminated array\n serving as character storage.\n\n If `CSTL_u16string_empty(instance) == true` the pointer is still\n valid and points to a single null character.\n\n The range `[CSTL_u16string_data(instance), CSTL_u16string_data(instance) + size]`\n is always valid.\n\n The array may be mutated through the returned pointer excluding\n the past-the-end null terminator.\n"]
    pub fn CSTL_u16string_data(instance: CSTL_UTF16StringRef) -> *mut char16_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the underlying null-terminated array\n serving as character storage.\n\n If `CSTL_u16string_empty(instance) == true` the pointer is still\n valid and points to a single null character.\n\n The range `[CSTL_u16string_c_str(instance), CSTL_u16string_c_str(instance) + size]`\n is always valid.\n"]
    pub fn CSTL_u16string_c_str(instance: CSTL_UTF16StringCRef) -> *const char16_t;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) to the first character of the string.\n\n If `CSTL_u16string_empty(instance) == true` then\n `CSTL_u16string_begin(instance) == CSTL_u16string_end(instance)`.\n"]
    pub fn CSTL_u16string_begin(instance: CSTL_UTF16StringRef) -> *mut char16_t;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) past the last character of the string.\n\n If `CSTL_u16string_empty(instance) == true` then\n `CSTL_u16string_begin(instance) == CSTL_u16string_end(instance)`.\n"]
    pub fn CSTL_u16string_const_begin(instance: CSTL_UTF16StringCRef) -> *const char16_t;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) past the last character of the string.\n\n If `CSTL_u16string_empty(instance) == true` then\n `CSTL_u16string_begin(instance) == CSTL_u16string_end(instance)`.\n"]
    pub fn CSTL_u16string_end(instance: CSTL_UTF16StringRef) -> *mut char16_t;
}
unsafe extern "C" {
    #[doc = " Returns a const iterator (pointer) past the last character of the string.\n\n If `CSTL_u16string_empty(instance) == true` then\n `CSTL_u16string_const_begin(instance) == CSTL_u16string_const_end(instance)`.\n"]
    pub fn CSTL_u16string_const_end(instance: CSTL_UTF16StringCRef) -> *const char16_t;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the string is empty or `false` otherwise.\n"]
    pub fn CSTL_u16string_empty(instance: CSTL_UTF16StringCRef) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters in the string.\n"]
    pub fn CSTL_u16string_size(instance: CSTL_UTF16StringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters in the string.\n"]
    pub fn CSTL_u16string_length(instance: CSTL_UTF16StringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the total characters capacity of the string.\n"]
    pub fn CSTL_u16string_capacity(instance: CSTL_UTF16StringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the maximum possible number of characters in the string.\n"]
    pub fn CSTL_u16string_max_size() -> usize;
}
unsafe extern "C" {
    #[doc = " If `new_capacity > CSTL_u16string_capacity(instance)`, reallocates and expands\n the underlying array storage.\n\n If `new_capacity` exceeds `CSTL_u16string_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_reserve(
        instance: CSTL_UTF16StringRef,
        new_capacity: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Request removal of unused capacity.\n"]
    pub fn CSTL_u16string_shrink_to_fit(instance: CSTL_UTF16StringRef, alloc: *mut CSTL_Alloc);
}
unsafe extern "C" {
    #[doc = " Erase all characters from the string without affecting capacity.\n"]
    pub fn CSTL_u16string_clear(instance: CSTL_UTF16StringRef);
}
unsafe extern "C" {
    #[doc = " Inserts the null-terminated string at `ptr` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u16string_insert(
        instance: CSTL_UTF16StringRef,
        where_: *const char16_t,
        ptr: *const char16_t,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char16_t;
}
unsafe extern "C" {
    #[doc = " Inserts the first `count` characters of the string at `ptr` at the pointer  `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u16string_insert_n(
        instance: CSTL_UTF16StringRef,
        where_: *const char16_t,
        ptr: *const char16_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char16_t;
}
unsafe extern "C" {
    #[doc = " Inserts `count` copies of the character `ch` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u16string_insert_char(
        instance: CSTL_UTF16StringRef,
        where_: *const char16_t,
        count: usize,
        ch: char16_t,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char16_t;
}
unsafe extern "C" {
    #[doc = " Inserts the string `other` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u16string_insert_str(
        instance: CSTL_UTF16StringRef,
        where_: *const char16_t,
        other: CSTL_UTF16StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char16_t;
}
unsafe extern "C" {
    #[doc = " Inserts the substring at offset `other_off` in `other` with the length\n given by `count` at the pointer `where` in `instance`.\n\n If `other_off` is outside of the range `[other, other + CSTL_u16string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u16string_insert_substr(
        instance: CSTL_UTF16StringRef,
        where_: *const char16_t,
        other: CSTL_UTF16StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char16_t;
}
unsafe extern "C" {
    #[doc = " Inserts the null-terminated string at `ptr` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u16string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_insert_at(
        instance: CSTL_UTF16StringRef,
        off: usize,
        ptr: *const char16_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the first `count` characters of the string at `ptr` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u16string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_insert_n_at(
        instance: CSTL_UTF16StringRef,
        off: usize,
        ptr: *const char16_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts `count` copies of the character `ch` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u16string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_insert_char_at(
        instance: CSTL_UTF16StringRef,
        off: usize,
        count: usize,
        ch: char16_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the string `other` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u16string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_insert_str_at(
        instance: CSTL_UTF16StringRef,
        off: usize,
        other: CSTL_UTF16StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the substring at offset `other_off` in `other` with the length\n given by `count` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u16string_size(instance)]`\n or if `other_off` is outside of the range `[other, other + CSTL_u16string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_insert_substr_at(
        instance: CSTL_UTF16StringRef,
        off: usize,
        other: CSTL_UTF16StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Removes the character at `where` and returns a pointer following the\n removed character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u16string_erase(
        instance: CSTL_UTF16StringRef,
        where_: *const char16_t,
    ) -> *mut char16_t;
}
unsafe extern "C" {
    #[doc = " Removes the characters in the range `[first, last)` and returns a pointer following the\n removed character.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u16string_erase_substr(
        instance: CSTL_UTF16StringRef,
        first: *const char16_t,
        last: *const char16_t,
    ) -> *mut char16_t;
}
unsafe extern "C" {
    #[doc = " Removes the character at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u16string_size(instance)]`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_erase_at(instance: CSTL_UTF16StringRef, off: usize) -> bool;
}
unsafe extern "C" {
    #[doc = " Removes the substring at offset `off` in `instance` with the length given by `count`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u16string_size(instance)]`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_erase_substr_at(
        instance: CSTL_UTF16StringRef,
        off: usize,
        count: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the character `ch` to the end of the string.\n\n If `CSTL_u16string_size(instance) == CSTL_u16string_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_push_back(
        instance: CSTL_UTF16StringRef,
        ch: char16_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the character `ch` to the end of the string.\n\n If `CSTL_u16string_size(instance) == CSTL_u16string_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_pop_back(instance: CSTL_UTF16StringRef);
}
unsafe extern "C" {
    #[doc = " Appends the null-terminated string at `ptr` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_append(
        instance: CSTL_UTF16StringRef,
        ptr: *const char16_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the first `count` characters of the string at `ptr` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_append_n(
        instance: CSTL_UTF16StringRef,
        ptr: *const char16_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends `count` copies of the character `ch` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_append_char(
        instance: CSTL_UTF16StringRef,
        count: usize,
        ch: char16_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the string `other` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_append_str(
        instance: CSTL_UTF16StringRef,
        other: CSTL_UTF16StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the substring at offset `other_off` in `other` with the length\n given by `count` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_append_substr(
        instance: CSTL_UTF16StringRef,
        other: CSTL_UTF16StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the null-terminated\n string at `ptr`.\n\n If the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u16string_replace(
        instance: CSTL_UTF16StringRef,
        first: *const char16_t,
        last: *const char16_t,
        ptr: *const char16_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the first `count`\n characters of the string at `ptr`.\n\n If the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u16string_replace_n(
        instance: CSTL_UTF16StringRef,
        first: *const char16_t,
        last: *const char16_t,
        ptr: *const char16_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with `count` copies\n of the character `ch`.\n\n If the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u16string_replace_char(
        instance: CSTL_UTF16StringRef,
        first: *const char16_t,
        last: *const char16_t,
        count: usize,
        ch: char16_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the string `other`.\n\n If the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u16string_replace_str(
        instance: CSTL_UTF16StringRef,
        first: *const char16_t,
        last: *const char16_t,
        other: CSTL_UTF16StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the substring\n at offset `other_off` in `other` with the length given by `count`.\n\n If `other_off` is outside of the range `[other, other + CSTL_u16string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u16string_replace_substr(
        instance: CSTL_UTF16StringRef,
        first: *const char16_t,
        last: *const char16_t,
        other: CSTL_UTF16StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the null-terminated string at `ptr`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u16string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_replace_at(
        instance: CSTL_UTF16StringRef,
        off: usize,
        count: usize,
        ptr: *const char16_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the first `count2` characters of the string at `ptr`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u16string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_replace_n_at(
        instance: CSTL_UTF16StringRef,
        off: usize,
        count: usize,
        ptr: *const char16_t,
        count2: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with `count` copies of the character `ch`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u16string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_replace_char_at(
        instance: CSTL_UTF16StringRef,
        off: usize,
        count: usize,
        count2: usize,
        ch: char16_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the string `other`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u16string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_replace_str_at(
        instance: CSTL_UTF16StringRef,
        off: usize,
        count: usize,
        other: CSTL_UTF16StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the substring at offset `other_off` in `other` with the length\n given by `count2`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u16string_size(instance)]`\n or if `other_off` is outside of the range `[other, other + CSTL_u16string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_u16string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_replace_substr_at(
        instance: CSTL_UTF16StringRef,
        off: usize,
        count: usize,
        other: CSTL_UTF16StringCRef,
        other_off: usize,
        count2: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Copies a substring `[off, off + count)` to character string pointed to by\n `dest`. The resulting character string is not null terminated.\n\n Returns the number of characters copied or `CSTL_string_npos` if\n `off > CSTL_u16string_size(instance)` (out of range).\n"]
    pub fn CSTL_u16string_copy(
        instance: CSTL_UTF16StringCRef,
        dest: *mut char16_t,
        count: usize,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Resizes the string to contain `new_size` characters, appending `ch`\n if current size is less than `new_size`.\n\n If `new_size` is greater than `CSTL_u16string_max_size()` this\n function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u16string_resize(
        instance: CSTL_UTF16StringRef,
        new_size: usize,
        ch: char16_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the null-terminated string `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u16string_find(
        instance: CSTL_UTF16StringCRef,
        ptr: *const char16_t,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the first `count` characters at `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u16string_find_n(
        instance: CSTL_UTF16StringCRef,
        ptr: *const char16_t,
        off: usize,
        count: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` occurence of the character `ch`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u16string_find_char(
        instance: CSTL_UTF16StringCRef,
        ch: char16_t,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the string `other`\n and return its position from the start of the original string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u16string_find_str(
        instance: CSTL_UTF16StringCRef,
        other: CSTL_UTF16StringCRef,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the null-terminated string `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u16string_rfind(
        instance: CSTL_UTF16StringCRef,
        ptr: *const char16_t,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the first `count` characters at `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u16string_rfind_n(
        instance: CSTL_UTF16StringCRef,
        ptr: *const char16_t,
        off: usize,
        count: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` occurence of the character `ch`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u16string_rfind_char(
        instance: CSTL_UTF16StringCRef,
        ch: char16_t,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the string `other`\n and return its position from the start of the original string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u16string_rfind_str(
        instance: CSTL_UTF16StringCRef,
        other: CSTL_UTF16StringCRef,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Compare two null-terminated character sequences.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n There is no `CSTL_UTF16String` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_u16string_compare(
        left: *const char16_t,
        right: *const char16_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compare an explicit length character sequence with a null-terminated one.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n To compare an explicit length `left` and a null-terminated `right`,\n swap them and negate the result: `-CSTL_u16string_compare_n(right, left, left_count)`.\n\n There is no `CSTL_UTF16String` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_u16string_compare_n(
        left: *const char16_t,
        right: *const char16_t,
        right_count: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compare two explicit length character sequences.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n There is no `CSTL_UTF16String` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_u16string_compare_nn(
        left: *const char16_t,
        left_count: usize,
        right: *const char16_t,
        right_count: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " STL ABI `std::basic_string` layout.\n\n Does not include the allocator, which nonetheless is a part of the `std::basic_string`\n structure! You are responsible for including it, since it can take on any form.\n\n Do not manipulate the members directly, use the associated functions!\n"]
#[repr(C)]
pub struct CSTL_UTF32StringVal {
    pub bx: CSTL_UTF32StringVal__bindgen_ty_1,
    pub size: usize,
    pub res: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CSTL_UTF32StringVal__bindgen_ty_1 {
    pub buf: [char32_t; 4usize],
    pub ptr: *mut char32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_UTF32StringVal__bindgen_ty_1"]
        [::std::mem::size_of::<CSTL_UTF32StringVal__bindgen_ty_1>() - 16usize];
    ["Alignment of CSTL_UTF32StringVal__bindgen_ty_1"]
        [::std::mem::align_of::<CSTL_UTF32StringVal__bindgen_ty_1>() - 8usize];
    ["Offset of field: CSTL_UTF32StringVal__bindgen_ty_1::buf"]
        [::std::mem::offset_of!(CSTL_UTF32StringVal__bindgen_ty_1, buf) - 0usize];
    ["Offset of field: CSTL_UTF32StringVal__bindgen_ty_1::ptr"]
        [::std::mem::offset_of!(CSTL_UTF32StringVal__bindgen_ty_1, ptr) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSTL_UTF32StringVal"][::std::mem::size_of::<CSTL_UTF32StringVal>() - 32usize];
    ["Alignment of CSTL_UTF32StringVal"][::std::mem::align_of::<CSTL_UTF32StringVal>() - 8usize];
    ["Offset of field: CSTL_UTF32StringVal::bx"]
        [::std::mem::offset_of!(CSTL_UTF32StringVal, bx) - 0usize];
    ["Offset of field: CSTL_UTF32StringVal::size"]
        [::std::mem::offset_of!(CSTL_UTF32StringVal, size) - 16usize];
    ["Offset of field: CSTL_UTF32StringVal::res"]
        [::std::mem::offset_of!(CSTL_UTF32StringVal, res) - 24usize];
};
#[doc = " Reference to a mutable `CSTL_UTF32StringVal`.\n\n Must not be null.\n"]
pub type CSTL_UTF32StringRef = *mut CSTL_UTF32StringVal;
#[doc = " Reference to a const `CSTL_UTF32StringVal`.\n\n Must not be null.\n"]
pub type CSTL_UTF32StringCRef = *const CSTL_UTF32StringVal;
unsafe extern "C" {
    #[doc = " Initializes the string, but does not allocate any memory.\n\n An initialized string can be trivially destroyed without leaks as long\n as its owned string is small enough to be inline (smaller than CSTL_string_alloc_mask).\n\n Re-initializing a string with a backing memory allocation will leak the old\n memory allocation.\n"]
    pub fn CSTL_u32string_construct(new_instance: *mut CSTL_UTF32StringVal);
}
unsafe extern "C" {
    #[doc = " Destroys the string, freeing the backing storage if necessary.\n"]
    pub fn CSTL_u32string_destroy(instance: CSTL_UTF32StringRef, alloc: *mut CSTL_Alloc);
}
unsafe extern "C" {
    #[doc = " Initializes the string with the substring at offset `other_off`\n in `other` with the length given by `count`.\n\n If `new_instance == NULL` or if `other_off` is outside of the range\n `[other, other + CSTL_u32string_size(other)]` returns `false` and does nothing,\n otherwise it returns `true`.\n\n If `new_instance == other` the substring operation is performed in-place without\n de-initializing `other`.\n\n Remember that re-initializing a different string with a backing memory allocation\n will leak the old memory allocation.\n"]
    pub fn CSTL_u32string_substr(
        new_instance: *mut CSTL_UTF32StringVal,
        other: CSTL_UTF32StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the null-terminated string at `ptr`.\n\n If the length of the string at `ptr` is greater than `CSTL_u32string_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_assign(
        instance: CSTL_UTF32StringRef,
        ptr: *const char32_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the first `count` characters of the string at `ptr`.\n\n If `n` is greater than `CSTL_u32string_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_assign_n(
        instance: CSTL_UTF32StringRef,
        ptr: *const char32_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the `count` copies of the character `ch`.\n\n If `count` is greater than `CSTL_u32string_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_assign_char(
        instance: CSTL_UTF32StringRef,
        count: usize,
        ch: char32_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the substring at offset `other_off` in `other`\n with the length given by `count`.\n\n If `other_off` is outside of the range `[other, other + CSTL_u32string_size(other)]` returns\n `false` and does nothing, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_assign_substr(
        instance: CSTL_UTF32StringRef,
        other: CSTL_UTF32StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of `instance` with the contents of `other_instance`.\n\n If `propagate_alloc == true && alloc != other_alloc` then storage\n is freed with `alloc` and allocated again with `other_alloc` before contents\n are copied. Then, `instance` uses `other_alloc` as its allocator.\n\n If `propagate_alloc == false` `instance` keeps using `alloc` as its allocator,\n potentially reusing its storage.\n\n You are responsible for replacing the allocator outside of `CSTL_UTF32StringVal` if applicable.\n"]
    pub fn CSTL_u32string_copy_assign(
        instance: CSTL_UTF32StringRef,
        alloc: *mut CSTL_Alloc,
        other_instance: CSTL_UTF32StringCRef,
        other_alloc: *mut CSTL_Alloc,
        propagate_alloc: bool,
    );
}
unsafe extern "C" {
    #[doc = " Moves the contents of `other_instance` to the contents of `instance`.\n\n If `propagate_alloc == true` storage is replaced with storage of `other_instance`.\n Then, `instance` uses `other_alloc` as its allocator.\n\n If `propagate_alloc == false && alloc != other_alloc` then storage is reused\n and individual characters of `other` are moved in. Then, `instance` uses `alloc` as its allocator.\n\n You are responsible for replacing the allocator outside of `CSTL_UTF32StringVal` if applicable.\n"]
    pub fn CSTL_u32string_move_assign(
        instance: CSTL_UTF32StringRef,
        alloc: *mut CSTL_Alloc,
        other_instance: CSTL_UTF32StringRef,
        other_alloc: *mut CSTL_Alloc,
        propagate_alloc: bool,
    );
}
unsafe extern "C" {
    #[doc = " Swaps string contents.\n\n You are responsible for swapping the allocators.\n"]
    pub fn CSTL_u32string_swap(instance: CSTL_UTF32StringRef, other_instance: CSTL_UTF32StringRef);
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the character at `pos`.\n\n If `pos >= CSTL_u32string_length(instance)` the behavior is undefined.\n"]
    pub fn CSTL_u32string_index(instance: CSTL_UTF32StringRef, pos: usize) -> *mut char32_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the character at `pos`.\n\n If `pos >= CSTL_u32string_length(instance)` the behavior is undefined.\n"]
    pub fn CSTL_u32string_const_index(
        instance: CSTL_UTF32StringCRef,
        pos: usize,
    ) -> *const char32_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the character at `pos`.\n\n If `pos >= CSTL_u32string_length(instance)` a null pointer is returned.\n"]
    pub fn CSTL_u32string_at(instance: CSTL_UTF32StringRef, pos: usize) -> *mut char32_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the character at `pos`.\n\n If `pos >= CSTL_u32string_length(instance)` a null pointer is returned.\n"]
    pub fn CSTL_u32string_const_at(instance: CSTL_UTF32StringCRef, pos: usize) -> *const char32_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the first character.\n\n If `CSTL_u32string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_u32string_front(instance: CSTL_UTF32StringRef) -> *mut char32_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the first character.\n\n If `CSTL_u32string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_u32string_const_front(instance: CSTL_UTF32StringCRef) -> *const char32_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the last character.\n\n If `CSTL_u32string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_u32string_back(instance: CSTL_UTF32StringRef) -> *mut char32_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the last character.\n\n If `CSTL_u32string_empty(instance) == true` the behavior is undefined.\n"]
    pub fn CSTL_u32string_const_back(instance: CSTL_UTF32StringCRef) -> *const char32_t;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the underlying null-terminated array\n serving as character storage.\n\n If `CSTL_u32string_empty(instance) == true` the pointer is still\n valid and points to a single null character.\n\n The range `[CSTL_u32string_data(instance), CSTL_u32string_data(instance) + size]`\n is always valid.\n\n The array may be mutated through the returned pointer excluding\n the past-the-end null terminator.\n"]
    pub fn CSTL_u32string_data(instance: CSTL_UTF32StringRef) -> *mut char32_t;
}
unsafe extern "C" {
    #[doc = " Returns a const pointer to the underlying null-terminated array\n serving as character storage.\n\n If `CSTL_u32string_empty(instance) == true` the pointer is still\n valid and points to a single null character.\n\n The range `[CSTL_u32string_c_str(instance), CSTL_u32string_c_str(instance) + size]`\n is always valid.\n"]
    pub fn CSTL_u32string_c_str(instance: CSTL_UTF32StringCRef) -> *const char32_t;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) to the first character of the string.\n\n If `CSTL_u32string_empty(instance) == true` then\n `CSTL_u32string_begin(instance) == CSTL_u32string_end(instance)`.\n"]
    pub fn CSTL_u32string_begin(instance: CSTL_UTF32StringRef) -> *mut char32_t;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) past the last character of the string.\n\n If `CSTL_u32string_empty(instance) == true` then\n `CSTL_u32string_begin(instance) == CSTL_u32string_end(instance)`.\n"]
    pub fn CSTL_u32string_const_begin(instance: CSTL_UTF32StringCRef) -> *const char32_t;
}
unsafe extern "C" {
    #[doc = " Returns an iterator (pointer) past the last character of the string.\n\n If `CSTL_u32string_empty(instance) == true` then\n `CSTL_u32string_begin(instance) == CSTL_u32string_end(instance)`.\n"]
    pub fn CSTL_u32string_end(instance: CSTL_UTF32StringRef) -> *mut char32_t;
}
unsafe extern "C" {
    #[doc = " Returns a const iterator (pointer) past the last character of the string.\n\n If `CSTL_u32string_empty(instance) == true` then\n `CSTL_u32string_const_begin(instance) == CSTL_u32string_const_end(instance)`.\n"]
    pub fn CSTL_u32string_const_end(instance: CSTL_UTF32StringCRef) -> *const char32_t;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the string is empty or `false` otherwise.\n"]
    pub fn CSTL_u32string_empty(instance: CSTL_UTF32StringCRef) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters in the string.\n"]
    pub fn CSTL_u32string_size(instance: CSTL_UTF32StringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters in the string.\n"]
    pub fn CSTL_u32string_length(instance: CSTL_UTF32StringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the total characters capacity of the string.\n"]
    pub fn CSTL_u32string_capacity(instance: CSTL_UTF32StringCRef) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the maximum possible number of characters in the string.\n"]
    pub fn CSTL_u32string_max_size() -> usize;
}
unsafe extern "C" {
    #[doc = " If `new_capacity > CSTL_u32string_capacity(instance)`, reallocates and expands\n the underlying array storage.\n\n If `new_capacity` exceeds `CSTL_u32string_max_size()` this function has no effect\n and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_reserve(
        instance: CSTL_UTF32StringRef,
        new_capacity: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Request removal of unused capacity.\n"]
    pub fn CSTL_u32string_shrink_to_fit(instance: CSTL_UTF32StringRef, alloc: *mut CSTL_Alloc);
}
unsafe extern "C" {
    #[doc = " Erase all characters from the string without affecting capacity.\n"]
    pub fn CSTL_u32string_clear(instance: CSTL_UTF32StringRef);
}
unsafe extern "C" {
    #[doc = " Inserts the null-terminated string at `ptr` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u32string_insert(
        instance: CSTL_UTF32StringRef,
        where_: *const char32_t,
        ptr: *const char32_t,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char32_t;
}
unsafe extern "C" {
    #[doc = " Inserts the first `count` characters of the string at `ptr` at the pointer  `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u32string_insert_n(
        instance: CSTL_UTF32StringRef,
        where_: *const char32_t,
        ptr: *const char32_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char32_t;
}
unsafe extern "C" {
    #[doc = " Inserts `count` copies of the character `ch` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u32string_insert_char(
        instance: CSTL_UTF32StringRef,
        where_: *const char32_t,
        count: usize,
        ch: char32_t,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char32_t;
}
unsafe extern "C" {
    #[doc = " Inserts the string `other` at the pointer `where` in `instance`.\n\n If the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u32string_insert_str(
        instance: CSTL_UTF32StringRef,
        where_: *const char32_t,
        other: CSTL_UTF32StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char32_t;
}
unsafe extern "C" {
    #[doc = " Inserts the substring at offset `other_off` in `other` with the length\n given by `count` at the pointer `where` in `instance`.\n\n If `other_off` is outside of the range `[other, other + CSTL_u32string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `NULL`, otherwise it returns a pointer\n to the first inserted character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u32string_insert_substr(
        instance: CSTL_UTF32StringRef,
        where_: *const char32_t,
        other: CSTL_UTF32StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> *mut char32_t;
}
unsafe extern "C" {
    #[doc = " Inserts the null-terminated string at `ptr` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u32string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_insert_at(
        instance: CSTL_UTF32StringRef,
        off: usize,
        ptr: *const char32_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the first `count` characters of the string at `ptr` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u32string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_insert_n_at(
        instance: CSTL_UTF32StringRef,
        off: usize,
        ptr: *const char32_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts `count` copies of the character `ch` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u32string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_insert_char_at(
        instance: CSTL_UTF32StringRef,
        off: usize,
        count: usize,
        ch: char32_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the string `other` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u32string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_insert_str_at(
        instance: CSTL_UTF32StringRef,
        off: usize,
        other: CSTL_UTF32StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Inserts the substring at offset `other_off` in `other` with the length\n given by `count` at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u32string_size(instance)]`\n or if `other_off` is outside of the range `[other, other + CSTL_u32string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_insert_substr_at(
        instance: CSTL_UTF32StringRef,
        off: usize,
        other: CSTL_UTF32StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Removes the character at `where` and returns a pointer following the\n removed character.\n\n The pointer `where` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u32string_erase(
        instance: CSTL_UTF32StringRef,
        where_: *const char32_t,
    ) -> *mut char32_t;
}
unsafe extern "C" {
    #[doc = " Removes the characters in the range `[first, last)` and returns a pointer following the\n removed character.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u32string_erase_substr(
        instance: CSTL_UTF32StringRef,
        first: *const char32_t,
        last: *const char32_t,
    ) -> *mut char32_t;
}
unsafe extern "C" {
    #[doc = " Removes the character at offset `off` in `instance`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u32string_size(instance)]`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_erase_at(instance: CSTL_UTF32StringRef, off: usize) -> bool;
}
unsafe extern "C" {
    #[doc = " Removes the substring at offset `off` in `instance` with the length given by `count`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u32string_size(instance)]`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_erase_substr_at(
        instance: CSTL_UTF32StringRef,
        off: usize,
        count: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the character `ch` to the end of the string.\n\n If `CSTL_u32string_size(instance) == CSTL_u32string_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_push_back(
        instance: CSTL_UTF32StringRef,
        ch: char32_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the character `ch` to the end of the string.\n\n If `CSTL_u32string_size(instance) == CSTL_u32string_max_size()` this function\n has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_pop_back(instance: CSTL_UTF32StringRef);
}
unsafe extern "C" {
    #[doc = " Appends the null-terminated string at `ptr` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_append(
        instance: CSTL_UTF32StringRef,
        ptr: *const char32_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the first `count` characters of the string at `ptr` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_append_n(
        instance: CSTL_UTF32StringRef,
        ptr: *const char32_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends `count` copies of the character `ch` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_append_char(
        instance: CSTL_UTF32StringRef,
        count: usize,
        ch: char32_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the string `other` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_append_str(
        instance: CSTL_UTF32StringRef,
        other: CSTL_UTF32StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Appends the substring at offset `other_off` in `other` with the length\n given by `count` to `instance`.\n\n If the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_append_substr(
        instance: CSTL_UTF32StringRef,
        other: CSTL_UTF32StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the null-terminated\n string at `ptr`.\n\n If the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u32string_replace(
        instance: CSTL_UTF32StringRef,
        first: *const char32_t,
        last: *const char32_t,
        ptr: *const char32_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the first `count`\n characters of the string at `ptr`.\n\n If the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u32string_replace_n(
        instance: CSTL_UTF32StringRef,
        first: *const char32_t,
        last: *const char32_t,
        ptr: *const char32_t,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with `count` copies\n of the character `ch`.\n\n If the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u32string_replace_char(
        instance: CSTL_UTF32StringRef,
        first: *const char32_t,
        last: *const char32_t,
        count: usize,
        ch: char32_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the string `other`.\n\n If the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u32string_replace_str(
        instance: CSTL_UTF32StringRef,
        first: *const char32_t,
        last: *const char32_t,
        other: CSTL_UTF32StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the characters in the range `[first, last)` with the substring\n at offset `other_off` in `other` with the length given by `count`.\n\n If `other_off` is outside of the range `[other, other + CSTL_u32string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n\n If `first == last`, no operation is performed.\n\n The range `[first, last)` must be valid and dereferenceable on `instance`.\n"]
    pub fn CSTL_u32string_replace_substr(
        instance: CSTL_UTF32StringRef,
        first: *const char32_t,
        last: *const char32_t,
        other: CSTL_UTF32StringCRef,
        other_off: usize,
        count: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the null-terminated string at `ptr`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u32string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_replace_at(
        instance: CSTL_UTF32StringRef,
        off: usize,
        count: usize,
        ptr: *const char32_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the first `count2` characters of the string at `ptr`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u32string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_replace_n_at(
        instance: CSTL_UTF32StringRef,
        off: usize,
        count: usize,
        ptr: *const char32_t,
        count2: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with `count` copies of the character `ch`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u32string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_replace_char_at(
        instance: CSTL_UTF32StringRef,
        off: usize,
        count: usize,
        count2: usize,
        ch: char32_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the string `other`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u32string_size(instance)]`\n or if the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_replace_str_at(
        instance: CSTL_UTF32StringRef,
        off: usize,
        count: usize,
        other: CSTL_UTF32StringCRef,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces the substring at offset `off` in `instance` with the length given by `count`\n with the substring at offset `other_off` in `other` with the length\n given by `count2`.\n\n If `off` is outside of the range `[instance, instance + CSTL_u32string_size(instance)]`\n or if `other_off` is outside of the range `[other, other + CSTL_u32string_size(other)]`\n or if the length of the resulting string is greater than `CSTL_u32string_max_size()`\n this function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_replace_substr_at(
        instance: CSTL_UTF32StringRef,
        off: usize,
        count: usize,
        other: CSTL_UTF32StringCRef,
        other_off: usize,
        count2: usize,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Copies a substring `[off, off + count)` to character string pointed to by\n `dest`. The resulting character string is not null terminated.\n\n Returns the number of characters copied or `CSTL_string_npos` if\n `off > CSTL_u32string_size(instance)` (out of range).\n"]
    pub fn CSTL_u32string_copy(
        instance: CSTL_UTF32StringCRef,
        dest: *mut char32_t,
        count: usize,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Resizes the string to contain `new_size` characters, appending `ch`\n if current size is less than `new_size`.\n\n If `new_size` is greater than `CSTL_u32string_max_size()` this\n function has no effect and returns `false`, otherwise it returns `true`.\n"]
    pub fn CSTL_u32string_resize(
        instance: CSTL_UTF32StringRef,
        new_size: usize,
        ch: char32_t,
        alloc: *mut CSTL_Alloc,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the null-terminated string `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u32string_find(
        instance: CSTL_UTF32StringCRef,
        ptr: *const char32_t,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the first `count` characters at `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u32string_find_n(
        instance: CSTL_UTF32StringCRef,
        ptr: *const char32_t,
        off: usize,
        count: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` occurence of the character `ch`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u32string_find_char(
        instance: CSTL_UTF32StringCRef,
        ch: char32_t,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the first from offset `off` substring equal to the string `other`\n and return its position from the start of the original string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u32string_find_str(
        instance: CSTL_UTF32StringCRef,
        other: CSTL_UTF32StringCRef,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the null-terminated string `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u32string_rfind(
        instance: CSTL_UTF32StringCRef,
        ptr: *const char32_t,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the first `count` characters at `ptr`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u32string_rfind_n(
        instance: CSTL_UTF32StringCRef,
        ptr: *const char32_t,
        off: usize,
        count: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` occurence of the character `ch`\n and return its position from the start of the string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u32string_rfind_char(
        instance: CSTL_UTF32StringCRef,
        ch: char32_t,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Find the last before offset `off` substring equal to the string `other`\n and return its position from the start of the original string.\n\n If no match is found `CSTL_string_npos` is returned.\n"]
    pub fn CSTL_u32string_rfind_str(
        instance: CSTL_UTF32StringCRef,
        other: CSTL_UTF32StringCRef,
        off: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Compare two null-terminated character sequences.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n There is no `CSTL_UTF32String` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_u32string_compare(
        left: *const char32_t,
        right: *const char32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compare an explicit length character sequence with a null-terminated one.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n To compare an explicit length `left` and a null-terminated `right`,\n swap them and negate the result: `-CSTL_u32string_compare_n(right, left, left_count)`.\n\n There is no `CSTL_UTF32String` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_u32string_compare_n(
        left: *const char32_t,
        right: *const char32_t,
        right_count: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compare two explicit length character sequences.\n\n The return value is negative if `left` compares less than `right`,\n positive if it compares greater and zero if `left` and `right`\n compare equal.\n\n There is no `CSTL_UTF32String` version of this function as the return\n value does not allow for reporting out of bounds errors.\n"]
    pub fn CSTL_u32string_compare_nn(
        left: *const char32_t,
        left_count: usize,
        right: *const char32_t,
        right_count: usize,
    ) -> ::std::os::raw::c_int;
}
